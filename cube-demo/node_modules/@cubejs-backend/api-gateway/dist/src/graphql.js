"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSchema = exports.getJsonQueryFromGraphQLQuery = exports.getJsonQuery = exports.TimeDimension = void 0;
const ramda_1 = __importDefault(require("ramda"));
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const nexus_1 = require("nexus");
const inflection_1 = require("inflection");
const graphql_scalars_1 = require("graphql-scalars");
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const enums_1 = require("./types/enums");
const DateTimeScalar = (0, nexus_1.asNexusMethod)(graphql_scalars_1.DateTimeResolver, 'date');
const FloatFilter = (0, nexus_1.inputObjectType)({
    name: 'FloatFilter',
    definition(t) {
        t.float('equals');
        t.float('notEquals');
        t.list.float('in');
        t.list.float('notIn');
        t.boolean('set');
        t.float('gt');
        t.float('lt');
        t.float('gte');
        t.float('lte');
    }
});
const StringFilter = (0, nexus_1.inputObjectType)({
    name: 'StringFilter',
    definition(t) {
        t.string('equals');
        t.string('notEquals');
        t.list.string('in');
        t.list.string('notIn');
        t.list.string('contains');
        t.list.string('notContains');
        t.list.string('startsWith');
        t.list.string('notStartsWith');
        t.list.string('notContains');
        t.list.string('endsWith');
        t.list.string('notEndsWith');
        t.boolean('set');
    }
});
const DateTimeFilter = (0, nexus_1.inputObjectType)({
    name: 'DateTimeFilter',
    definition(t) {
        t.list.string('equals');
        t.list.string('notEquals');
        t.list.string('in');
        t.list.string('notIn');
        t.list.string('inDateRange');
        t.list.string('notInDateRange');
        t.string('beforeDate');
        t.string('beforeOrOnDate');
        t.string('afterDate');
        t.string('afterOrOnDate');
        t.boolean('set');
    }
});
const OrderBy = (0, nexus_1.enumType)({
    name: 'OrderBy',
    members: [
        'asc',
        'desc'
    ]
});
exports.TimeDimension = (0, nexus_1.objectType)({
    name: 'TimeDimension',
    definition(t) {
        t.nonNull.field('value', {
            type: 'DateTime',
        });
        t.nonNull.field('second', {
            type: 'DateTime',
        });
        t.nonNull.field('minute', {
            type: 'DateTime',
        });
        t.nonNull.field('hour', {
            type: 'DateTime',
        });
        t.nonNull.field('day', {
            type: 'DateTime',
        });
        t.nonNull.field('week', {
            type: 'DateTime',
        });
        t.nonNull.field('month', {
            type: 'DateTime',
        });
        t.nonNull.field('quarter', {
            type: 'DateTime'
        });
        t.nonNull.field('year', {
            type: 'DateTime',
        });
    },
});
function mapType(type, isInputType) {
    switch (type) {
        case 'time':
            return isInputType ? 'DateTime' : 'TimeDimension';
        case 'string':
            return 'String';
        case 'number':
            return 'Float';
        default:
            return 'String';
    }
}
function mapWhereOperator(operator, value) {
    switch (operator) {
        case 'in':
            return 'equals';
        case 'notIn':
            return 'notEquals';
        case 'set':
            return (value === true) ? 'set' : 'notSet';
        default:
            return operator;
    }
}
function mapWhereValue(operator, value) {
    value = Array.isArray(value) ? value.map(v => v.toString()) : [value.toString()];
    if (operator === 'set') {
        return undefined;
    }
    else if (['inDateRange', 'notInDateRange'].includes(operator)) {
        if (value.length === 1 && !/^\d\d\d\d-\d\d-\d\d/.test(value[0])) {
            return value[0].toString();
        }
    }
    return value;
}
function safeName(name) {
    return name.split('.').slice(1).join('');
}
function objectName(name) {
    return (0, inflection_1.camelize)(name, false);
}
function capitalize(name) {
    return `${name[0].toUpperCase()}${name.slice(1)}`;
}
function unCapitalize(name) {
    return `${name[0].toLowerCase()}${name.slice(1)}`;
}
function applyDirectives(directives, values) {
    if (directives === undefined || directives.length === 0) {
        return true;
    }
    return directives.reduce((result, directive) => {
        directive.arguments?.forEach((argument) => {
            if (argument.name.value === 'if') {
                if ((directive.name.value === 'include' &&
                    !values[argument.value.name.value]) ||
                    (directive.name.value === 'skip' &&
                        values[argument.value.name.value])) {
                    result = false;
                }
            }
        });
        return result;
    }, true);
}
function getFieldNodeChildren(node, infos) {
    return (node.selectionSet?.selections.filter((childNode) => (childNode.kind === 'Field' &&
        childNode.name.value !== '__typename' &&
        applyDirectives(childNode.directives, infos.variableValues))) || []);
}
function parseArgumentValue(value, variables) {
    switch (value.kind) {
        case 'BooleanValue':
        case 'IntValue':
        case 'StringValue':
        case 'FloatValue':
        case 'EnumValue':
            return value.value;
        case 'ListValue':
            return value.values.map(v => parseArgumentValue(v, variables));
        case 'ObjectValue':
            return value.fields.reduce((obj, v) => ({
                ...obj,
                [v.name.value]: parseArgumentValue(v.value, variables),
            }), {});
        case 'Variable':
            if (variables?.[value.name.value] === undefined) {
                throw new Error(`Variable "${value.name.value}" is not defined`);
            }
            return variables[value.name.value];
        default:
            return undefined;
    }
}
function getArgumentValue(node, argName, variables = {}) {
    const argument = node.arguments?.find(a => a.name.value === argName)?.value;
    if (argument?.kind === 'Variable') {
        const varValue = variables[argument.name.value];
        if (varValue === undefined) {
            throw new Error(`Variable "${argument.name.value}" is not defined`);
        }
        return variables[argument.name.value];
    }
    return argument ? parseArgumentValue(argument, variables) : argument;
}
function getMemberType(metaConfig, cubeName, memberName) {
    const cubeConfig = metaConfig.find(cube => (cube.config.name === cubeName) || cube.config.name === capitalize(cubeName));
    if (!cubeConfig)
        return undefined;
    return [enums_1.MemberType.MEASURES, enums_1.MemberType.DIMENSIONS].find((memberType) => (cubeConfig.config[memberType]
        .findIndex(entry => entry.name === `${cubeName}.${memberName}` || entry.name === `${capitalize(cubeName)}.${memberName}`) !== -1));
}
function whereArgToQueryFilters(whereArg, prefix, metaConfig = []) {
    const queryFilters = [];
    Object.keys(whereArg).forEach((key) => {
        const cubeExists = metaConfig.find((cube) => cube.config.name === key);
        const normalizedKey = cubeExists ? key : capitalize(key);
        if (['OR', 'AND'].includes(key)) {
            queryFilters.push({
                [key.toLowerCase()]: whereArg[key].reduce((filters, whereBooleanArg) => [
                    ...filters,
                    ...whereArgToQueryFilters(whereBooleanArg, prefix, metaConfig),
                ], []),
            });
        }
        else if (whereArg[key].OR || whereArg[key].AND) {
            // users: {
            //   OR: {
            //     name: { equals: "Alex" }
            //     country: { equals: "US" }
            //   } # <-- a single boolean filter can be passed in directly
            //   age: { equals: 28 } # <-- will require AND
            // }
            if (Object.keys(whereArg[key]).length > 1) {
                queryFilters.push(...whereArgToQueryFilters({
                    AND: Object.entries(whereArg[key]).reduce((memo, [k, v]) => [...memo, { [k]: v }], []),
                }, normalizedKey, metaConfig));
            }
            else {
                const res = whereArgToQueryFilters(whereArg[key], normalizedKey, metaConfig);
                queryFilters.push(...res);
            }
        }
        else if (prefix) {
            // handle a subfilter
            // { country: { in: ["US"] }
            Object.entries(whereArg[key]).forEach(([operator, value]) => {
                queryFilters.push({
                    member: `${prefix}.${key}`,
                    operator: mapWhereOperator(operator, value),
                    ...(mapWhereValue(operator, value) && {
                        values: mapWhereValue(operator, value),
                    }),
                });
            });
        }
        else {
            Object.entries(whereArg[key]).forEach(([member, filters]) => {
                Object.entries(filters).forEach(([operator, value]) => {
                    queryFilters.push({
                        member: prefix
                            ? `${prefix}.${key}`
                            : `${normalizedKey}.${member}`,
                        operator: mapWhereOperator(operator, value),
                        ...(mapWhereValue(operator, value) && {
                            values: mapWhereValue(operator, value),
                        }),
                    });
                });
            });
        }
    });
    return queryFilters;
}
function parseDates(result) {
    const { timezone } = result.query;
    const dateKeys = Object.entries({
        ...result.annotation.measures,
        ...result.annotation.dimensions,
        ...result.annotation.timeDimensions,
    }).reduce((res, [key, value]) => (value.type === 'time' ? [...res, key] : res), []);
    result.data.forEach(row => {
        Object.keys(row).forEach(key => {
            if (dateKeys.includes(key)) {
                row[key] = moment_timezone_1.default.tz(row[key], timezone).toISOString();
            }
            return row;
        });
    });
}
function getJsonQuery(metaConfig, args, infos) {
    const { where, limit, offset, timezone, orderBy, renewQuery, ungrouped } = args;
    const measures = [];
    const dimensions = [];
    const timeDimensions = [];
    let filters = [];
    const order = [];
    if (where) {
        filters = whereArgToQueryFilters(where, undefined, metaConfig);
    }
    if (orderBy) {
        Object.entries(orderBy).forEach(([cubeName, members]) => {
            Object.entries(members).forEach(([member, value]) => {
                order.push([`${capitalize(cubeName)}.${member}`, value]);
            });
        });
    }
    getFieldNodeChildren(infos.fieldNodes[0], infos).forEach(cubeNode => {
        const cubeExists = metaConfig.find((cube) => cube.config.name === cubeNode.name.value);
        const cubeName = cubeExists ? (cubeNode.name.value) : capitalize(cubeNode.name.value);
        const orderByArg = getArgumentValue(cubeNode, 'orderBy', infos.variableValues);
        // todo: throw if both RootOrderByInput and [Cube]OrderByInput provided
        if (orderByArg) {
            Object.keys(orderByArg).forEach(key => {
                order.push([`${cubeName}.${key}`, orderByArg[key]]);
            });
        }
        const whereArg = getArgumentValue(cubeNode, 'where', infos.variableValues);
        if (whereArg) {
            filters = whereArgToQueryFilters(whereArg, cubeName).concat(filters);
        }
        // Push down all inDateRange filters to time dimensions to leverage pre-aggregations
        const dateRangeFilters = {};
        filters = filters.filter((f) => {
            if (f.operator === 'inDateRange' && !dateRangeFilters[f.member]) {
                dateRangeFilters[f.member] = f.values;
                return false;
            }
            return true;
        });
        getFieldNodeChildren(cubeNode, infos).forEach(memberNode => {
            const memberName = memberNode.name.value;
            const memberType = getMemberType(metaConfig, cubeName, memberName);
            const key = `${cubeName}.${memberName}`;
            if (memberType === enums_1.MemberType.MEASURES) {
                measures.push(key);
            }
            else if (memberType === enums_1.MemberType.DIMENSIONS) {
                const granularityNodes = getFieldNodeChildren(memberNode, infos);
                if (granularityNodes.length > 0) {
                    granularityNodes.forEach(granularityNode => {
                        const granularityName = granularityNode.name.value;
                        if (granularityName === 'value') {
                            dimensions.push(key);
                        }
                        else {
                            timeDimensions.push({
                                dimension: key,
                                granularity: granularityName,
                                ...(dateRangeFilters[key] ? {
                                    dateRange: dateRangeFilters[key],
                                } : null)
                            });
                        }
                    });
                }
                else {
                    dimensions.push(`${cubeName}.${memberName}`);
                }
            }
        });
        if (Object.keys(dateRangeFilters).length && !timeDimensions.length) {
            Object.entries(dateRangeFilters).forEach(([dimension, dateRange]) => {
                timeDimensions.push({
                    dimension,
                    dateRange
                });
            });
        }
    });
    return {
        ...(measures.length && { measures }),
        ...(dimensions.length && { dimensions }),
        ...(timeDimensions.length && { timeDimensions }),
        ...(Object.keys(order).length && { order }),
        ...(limit && { limit }),
        ...(offset && { offset }),
        ...(timezone && { timezone }),
        ...(filters.length && { filters }),
        ...(renewQuery && { renewQuery }),
        ...(ungrouped && { ungrouped }),
    };
}
exports.getJsonQuery = getJsonQuery;
function getJsonQueryFromGraphQLQuery(query, metaConfig, variableValues = {}) {
    const ast = (0, graphql_tag_1.default)(query);
    const operation = ast.definitions.find(({ kind }) => kind === 'OperationDefinition');
    const fieldNodes = operation?.selectionSet.selections;
    let args = {};
    for (const argument of fieldNodes[0].arguments) {
        args = { ...args, [argument.name.value]: parseArgumentValue(argument.value, variableValues) };
    }
    const resolveInfo = {
        fieldName: fieldNodes[0]?.name.value || '',
        fieldNodes,
        rootValue: {},
        operation,
        variableValues,
        fragments: {},
    };
    return getJsonQuery(metaConfig, args, resolveInfo);
}
exports.getJsonQueryFromGraphQLQuery = getJsonQueryFromGraphQLQuery;
function makeSchema(metaConfig) {
    const types = [
        DateTimeScalar,
        FloatFilter,
        StringFilter,
        DateTimeFilter,
        OrderBy,
        exports.TimeDimension
    ];
    function hasMembers(cube) {
        if (cube.public === false) {
            return false;
        }
        return ([...cube.config.measures, ...cube.config.dimensions].filter((member) => member.isVisible)).length > 0;
    }
    metaConfig.forEach(cube => {
        if (hasMembers(cube)) {
            types.push((0, nexus_1.objectType)({
                name: `${objectName(cube.config.name)}Members`,
                definition(t) {
                    cube.config.measures.forEach(measure => {
                        if (measure.isVisible) {
                            t.field(safeName(measure.name), {
                                type: mapType(measure.type),
                                description: measure.description
                            });
                        }
                    });
                    cube.config.dimensions.forEach(dimension => {
                        if (dimension.isVisible) {
                            t.field(safeName(dimension.name), {
                                type: mapType(dimension.type),
                                description: dimension.description
                            });
                        }
                    });
                }
            }));
            types.push((0, nexus_1.inputObjectType)({
                name: `${objectName(cube.config.name)}WhereInput`,
                definition(t) {
                    t.field('AND', { type: (0, nexus_1.list)((0, nexus_1.nonNull)(`${objectName(cube.config.name)}WhereInput`)) });
                    t.field('OR', { type: (0, nexus_1.list)((0, nexus_1.nonNull)(`${objectName(cube.config.name)}WhereInput`)) });
                    cube.config.measures.forEach(measure => {
                        if (measure.isVisible) {
                            t.field(safeName(measure.name), {
                                type: `${mapType(measure.type, true)}Filter`,
                            });
                        }
                    });
                    cube.config.dimensions.forEach(dimension => {
                        if (dimension.isVisible) {
                            t.field(safeName(dimension.name), {
                                type: `${mapType(dimension.type, true)}Filter`,
                            });
                        }
                    });
                }
            }));
            types.push((0, nexus_1.inputObjectType)({
                name: `${objectName(cube.config.name)}OrderByInput`,
                definition(t) {
                    cube.config.measures.forEach(measure => {
                        if (measure.isVisible) {
                            t.field(safeName(measure.name), {
                                type: 'OrderBy',
                            });
                        }
                    });
                    cube.config.dimensions.forEach(dimension => {
                        if (dimension.isVisible) {
                            t.field(safeName(dimension.name), {
                                type: 'OrderBy',
                            });
                        }
                    });
                }
            }));
        }
    });
    types.push((0, nexus_1.inputObjectType)({
        name: 'RootWhereInput',
        definition(t) {
            t.field('AND', { type: (0, nexus_1.list)((0, nexus_1.nonNull)('RootWhereInput')) });
            t.field('OR', { type: (0, nexus_1.list)((0, nexus_1.nonNull)('RootWhereInput')) });
            metaConfig.forEach(cube => {
                if (hasMembers(cube)) {
                    t.field(unCapitalize(cube.config.name), {
                        type: `${objectName(cube.config.name)}WhereInput`
                    });
                }
            });
        }
    }));
    types.push((0, nexus_1.inputObjectType)({
        name: 'RootOrderByInput',
        definition(t) {
            metaConfig.forEach(cube => {
                if (hasMembers(cube)) {
                    t.field(unCapitalize(cube.config.name), {
                        type: `${objectName(cube.config.name)}OrderByInput`
                    });
                }
            });
        }
    }));
    types.push((0, nexus_1.objectType)({
        name: 'Result',
        definition(t) {
            metaConfig.forEach(cube => {
                if (hasMembers(cube)) {
                    t.nonNull.field(unCapitalize(cube.config.name), {
                        type: `${objectName(cube.config.name)}Members`,
                        args: {
                            where: (0, nexus_1.arg)({
                                type: `${objectName(cube.config.name)}WhereInput`
                            }),
                            orderBy: (0, nexus_1.arg)({
                                type: `${objectName(cube.config.name)}OrderByInput`
                            }),
                        }
                    });
                }
            });
        }
    }));
    types.push((0, nexus_1.extendType)({
        type: 'Query',
        definition(t) {
            t.nonNull.field('cube', {
                type: (0, nexus_1.list)((0, nexus_1.nonNull)('Result')),
                args: {
                    where: (0, nexus_1.arg)({
                        type: 'RootWhereInput'
                    }),
                    limit: (0, nexus_1.intArg)(),
                    offset: (0, nexus_1.intArg)(),
                    timezone: (0, nexus_1.stringArg)(),
                    renewQuery: (0, nexus_1.booleanArg)(),
                    ungrouped: (0, nexus_1.booleanArg)(),
                    orderBy: (0, nexus_1.arg)({
                        type: 'RootOrderByInput'
                    }),
                },
                resolve: async (_, args, { req, apiGateway }, info) => {
                    const query = getJsonQuery(metaConfig, args, info);
                    const results = await new Promise((resolve, reject) => {
                        apiGateway.load({
                            query,
                            queryType: enums_1.QueryType.REGULAR_QUERY,
                            context: req.context,
                            res: (message) => {
                                if (message.error) {
                                    reject(new Error(message.error));
                                }
                                resolve(message);
                            },
                            apiType: 'graphql',
                        }).catch(reject);
                    });
                    parseDates(results);
                    return results.data.map(entry => ramda_1.default.toPairs(entry)
                        .reduce((res, pair) => {
                        let path = pair[0].split('.');
                        path[0] = unCapitalize(path[0]);
                        if (results.annotation.dimensions[pair[0]]?.type === 'time') {
                            path = [...path, 'value'];
                        }
                        return (results.annotation.timeDimensions[pair[0]] && path.length !== 3)
                            ? res : ramda_1.default.set(ramda_1.default.lensPath(path), pair[1], res);
                    }, {}));
                }
            });
        }
    }));
    return (0, nexus_1.makeSchema)({ types });
}
exports.makeSchema = makeSchema;
//# sourceMappingURL=graphql.js.map