/// <reference types="node" />
import * as stream from 'stream';
import type { Application as ExpressApplication, ErrorRequestHandler, RequestHandler, Response as ExpressResponse } from 'express';
import { QueryType, ApiScopes } from './types/strings';
import { RequestContext, ExtendedRequestContext, Request, QueryRewriteFn, SecurityContextExtractorFn, ExtendContextFn, ResponseResultFn, QueryRequest, SqlApiRequest, MetaResponseResultFn } from './types/request';
import { CheckAuthInternalOptions, JWTOptions, CheckAuthFn, ContextToApiScopesFn } from './types/auth';
import { Query, NormalizedQuery } from './types/query';
import { UserBackgroundContext, ApiGatewayOptions } from './types/gateway';
import { CheckAuthMiddlewareFn, RequestLoggerMiddlewareFn, ContextRejectionMiddlewareFn, ContextAcceptorFn } from './interfaces';
import { SubscriptionServer, WebSocketSendMessageFn } from './SubscriptionServer';
import { SQLServer, SQLServerConstructorOptions } from './sql-server';
type HandleErrorOptions = {
    e: any;
    res: ResponseResultFn;
    context?: any;
    query?: any;
    requestStarted?: Date;
};
type PreparedCheckAuthFn = (ctx: any, authorization?: string) => Promise<void>;
declare class ApiGateway {
    protected readonly apiSecret: string;
    protected readonly compilerApi: (ctx: RequestContext) => Promise<any>;
    protected readonly adapterApi: (ctx: RequestContext) => Promise<any>;
    protected readonly logger: any;
    protected readonly options: ApiGatewayOptions;
    protected readonly refreshScheduler: any;
    protected readonly scheduledRefreshContexts: ApiGatewayOptions['scheduledRefreshContexts'];
    protected readonly scheduledRefreshTimeZones: ApiGatewayOptions['scheduledRefreshTimeZones'];
    protected readonly basePath: string;
    protected readonly queryRewrite: QueryRewriteFn;
    protected readonly subscriptionStore: any;
    protected readonly enforceSecurityChecks: boolean;
    protected readonly standalone: boolean;
    protected readonly extendContext?: ExtendContextFn;
    protected readonly dataSourceStorage: any;
    readonly checkAuthFn: PreparedCheckAuthFn;
    readonly checkAuthSystemFn: PreparedCheckAuthFn;
    protected readonly contextToApiScopesFn: ContextToApiScopesFn;
    protected readonly contextToApiScopesDefFn: ContextToApiScopesFn;
    protected readonly checkAuthMiddleware: CheckAuthMiddlewareFn;
    protected readonly requestLoggerMiddleware: RequestLoggerMiddlewareFn;
    protected readonly securityContextExtractor: SecurityContextExtractorFn;
    protected readonly contextRejectionMiddleware: ContextRejectionMiddlewareFn;
    protected readonly wsContextAcceptor: ContextAcceptorFn;
    protected readonly releaseListeners: (() => any)[];
    protected readonly playgroundAuthSecret?: string;
    protected readonly event: (name: string, props?: object) => void;
    protected readonly sqlServer: SQLServer;
    constructor(apiSecret: string, compilerApi: (ctx: RequestContext) => Promise<any>, adapterApi: (ctx: RequestContext) => Promise<any>, logger: any, options: ApiGatewayOptions);
    getSQLServer(): SQLServer;
    protected createSQLServerInstance(options: SQLServerConstructorOptions): SQLServer;
    initApp(app: ExpressApplication): void;
    initSubscriptionServer(sendMessage: WebSocketSendMessageFn): SubscriptionServer;
    protected duration(requestStarted: any): any;
    runScheduledRefresh({ context, res, queryingOptions }: {
        context: RequestContext;
        res: ResponseResultFn;
        queryingOptions: any;
    }): Promise<void>;
    private filterVisibleItemsInMeta;
    meta({ context, res, includeCompilerId, onlyCompilerId }: {
        context: RequestContext;
        res: MetaResponseResultFn;
        includeCompilerId?: boolean;
        onlyCompilerId?: boolean;
    }): Promise<void>;
    metaExtended({ context, res }: {
        context: ExtendedRequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregations({ cacheOnly, context, res }: {
        cacheOnly?: boolean;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationPartitions({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationPreview({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    buildPreAggregations({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    /**
     * Entry point for the `/cubejs-system/v1/pre-aggregations/jobs` endpoint.
     * Post object example:
     * ```
     * {
     *   "action": "post",
     *   "selector": {
     *     "contexts": [
     *       {"securityContext": {"tenant": "t1"}},
     *       {"securityContext": {"tenant": "t2"}}
     *     ],
     *     "timezones": ["UTC"],
     *     "dataSources": ["default"],
     *     "cubes": ["Events"],
     *     "preAggregations": ["Events.TemporaryData"]
     *   }
     * }
     * // or
     * {
     *   "action": "get",
     *   "tokens": [
     *     "ec1232ea3356f04f8be313fecf3deb4d",
     *     "48b75d5c466fa579c936dc451f498f69",
     *     "76509837091396dc204abb1016c48e75",
     *     "52264769f81f6ff62062a93d6f6fbdb2"
     *   ]
     * }
     * // or
     * {
     *   "action": "get",
     *   "resType": "object",
     *   "tokens": [
     *     "ec1232ea3356f04f8be313fecf3deb4d",
     *     "48b75d5c466fa579c936dc451f498f69",
     *     "76509837091396dc204abb1016c48e75",
     *     "52264769f81f6ff62062a93d6f6fbdb2"
     *   ]
     * }
     * ```
     * TODO (buntarb): selector object validator.
     */
    private preAggregationsJobs;
    /**
     * Post pre-aggregations build jobs entry point.
     */
    private preAggregationsJobsPOST;
    /**
     * Add pre-aggregations build job. Returns added jobs ids.
     */
    private postPreAggregationsBuildJobs;
    /**
     * Get pre-aggregations build jobs entry point.
     */
    private preAggregationsJobsGET;
    /**
     * Returns PreAggJob status if it still in queue, false otherwise.
     */
    private getPreAggJobQueueStatus;
    /**
     * Returns PreAggJob execution status.
     */
    private getPreAggJobResultStatus;
    getPreAggregationsInQueue({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    cancelPreAggregationsFromQueue({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    /**
     * Convert incoming query parameter (JSON fetched from the HTTP) to
     * an array of query type and array of normalized queries.
     */
    protected getNormalizedQueries(inputQuery: Record<string, any> | Record<string, any>[], context: RequestContext, persistent?: boolean, memberExpressions?: boolean): Promise<[QueryType, NormalizedQuery[]]>;
    sql({ query, context, res, memberToAlias, exportAnnotatedSql, memberExpressions, expressionParams, disableExternalPreAggregations, disableLimitEnforcing, }: QueryRequest): Promise<void>;
    private hasExpressionsInQuery;
    private parseMemberExpressionsInQuery;
    private parseMemberExpression;
    private evalMemberExpressionsInQuery;
    private evalMemberExpression;
    sqlGenerators({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    protected createSecurityContextExtractor(options?: JWTOptions): SecurityContextExtractorFn;
    protected coerceForSqlQuery(query: any, context: Readonly<RequestContext>): any;
    protected dryRun({ query, context, res }: QueryRequest): Promise<void>;
    /**
     * Returns an array of sqlQuery objects for specified normalized
     * queries.
     * @internal
     */
    private getSqlQueriesInternal;
    /**
     * Execute query and return adapter's result.
     * @internal
     */
    private getSqlResponseInternal;
    /**
     * Convert adapter's result and other request paramters to a final
     * result object.
     * @internal
     */
    private getResultInternal;
    /**
     * Returns stream object which will be used to stream results from
     * the data source if applicable, returns `null` otherwise.
     */
    stream(context: RequestContext, query: Query): Promise<null | {
        originalQuery: Query;
        normalizedQuery: NormalizedQuery;
        streamingQuery: unknown;
        stream: stream.Writable;
    }>;
    /**
     * Data queries APIs (`/load`, `/subscribe`) entry point. Used by
     * `CubejsApi#load` and `CubejsApi#subscribe` methods to fetch the
     * data.
     */
    load(request: QueryRequest): Promise<void>;
    sqlApiLoad(request: SqlApiRequest): Promise<void>;
    subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }: {
        context: any;
        signedWithPlaygroundAuthSecret: any;
        connectionId: any;
        res: any;
    }): Promise<any>;
    unSubscribeQueueEvents({ context, connectionId }: {
        context: any;
        connectionId: any;
    }): Promise<any>;
    subscribe({ query, context, res, subscribe, subscriptionState, queryType, apiType }: {
        query: any;
        context: any;
        res: any;
        subscribe: any;
        subscriptionState: any;
        queryType: any;
        apiType: any;
    }): Promise<void>;
    protected resToResultFn(res: ExpressResponse): (message: any, { status }?: {
        status?: number | undefined;
    }) => ExpressResponse<any, Record<string, any>>;
    protected parseQueryParam(query: any): Query | Query[];
    protected getCompilerApi(context: RequestContext): Promise<any>;
    protected getAdapterApi(context: RequestContext): Promise<any>;
    contextByReq(req: Request, securityContext: any, requestId: string): Promise<ExtendedRequestContext>;
    protected handleErrorMiddleware: ErrorRequestHandler;
    handleError({ e, context, query, res, requestStarted }: HandleErrorOptions): void;
    protected wrapCheckAuthMiddleware(fn: CheckAuthMiddlewareFn): CheckAuthMiddlewareFn;
    protected wrapCheckAuth(fn: CheckAuthFn): PreparedCheckAuthFn;
    protected createDefaultCheckAuth(options?: JWTOptions, internalOptions?: CheckAuthInternalOptions): PreparedCheckAuthFn;
    protected createCheckAuthFn(options: ApiGatewayOptions): PreparedCheckAuthFn;
    protected createCheckAuthSystemFn(): PreparedCheckAuthFn;
    protected createContextToApiScopesFn(options: ApiGatewayOptions): ContextToApiScopesFn;
    protected assertApiScope(scope: ApiScopes, securityContext?: any): Promise<void>;
    protected extractAuthorizationHeaderWithSchema(req: Request): string | undefined;
    protected checkAuthWrapper(checkAuthFn: PreparedCheckAuthFn, req: Request, res: ExpressResponse, next: any): Promise<void>;
    protected checkAuth: RequestHandler;
    protected checkAuthSystemMiddleware: RequestHandler;
    protected requestContextMiddleware: RequestHandler;
    protected requestLogger: RequestHandler;
    protected logNetworkUsage: RequestHandler;
    protected compareDateRangeTransformer(query: any): any;
    log(event: {
        type: string;
        [key: string]: any;
    }, context?: Partial<RequestContext>): void;
    protected healthResponse(res: ExpressResponse, health: 'HEALTH' | 'DOWN'): void;
    protected createSystemContextHandler: (basePath: string) => RequestHandler;
    private logProbeError;
    protected readiness: RequestHandler;
    protected liveness: RequestHandler;
    release(): void;
}
export { UserBackgroundContext, ApiGatewayOptions, ApiGateway, };
//# sourceMappingURL=gateway.d.ts.map