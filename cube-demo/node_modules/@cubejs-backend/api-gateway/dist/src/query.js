"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remapToQueryAdapterFormat = exports.normalizeQueryCancelPreAggregations = exports.normalizeQueryPreAggregationPreview = exports.normalizeQueryPreAggregations = exports.normalizeQuery = exports.getPivotQuery = exports.getQueryGranularity = void 0;
const ramda_1 = __importDefault(require("ramda"));
const moment_1 = __importDefault(require("moment"));
const joi_1 = __importDefault(require("joi"));
const shared_1 = require("@cubejs-backend/shared");
const UserError_1 = require("./UserError");
const dateParser_1 = require("./dateParser");
const enums_1 = require("./types/enums");
const getQueryGranularity = (queries) => ramda_1.default.pipe(ramda_1.default.map(({ timeDimensions }) => timeDimensions[0] && timeDimensions[0].granularity || null), ramda_1.default.filter(Boolean), ramda_1.default.uniq)(queries);
exports.getQueryGranularity = getQueryGranularity;
const getPivotQuery = (queryType, queries) => {
    let [pivotQuery] = queries;
    if (queryType === enums_1.QueryType.BLENDING_QUERY) {
        pivotQuery = ramda_1.default.fromPairs(['measures', 'dimensions'].map((key) => [key, ramda_1.default.uniq(queries.reduce((memo, q) => memo.concat(q[key]), []))]));
        const [granularity] = getQueryGranularity(queries);
        pivotQuery.timeDimensions = [{
                dimension: 'time',
                granularity
            }];
    }
    else if (queryType === enums_1.QueryType.COMPARE_DATE_RANGE_QUERY) {
        pivotQuery.dimensions = ['compareDateRange'].concat(pivotQuery.dimensions || []);
    }
    pivotQuery.queryType = queryType;
    return pivotQuery;
};
exports.getPivotQuery = getPivotQuery;
const id = joi_1.default.string().regex(/^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$/);
const idOrMemberExpressionName = joi_1.default.string().regex(/^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$|^[a-zA-Z0-9_]+$/);
const dimensionWithTime = joi_1.default.string().regex(/^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+(\.(second|minute|hour|day|week|month|year))?$/);
const parsedMemberExpression = joi_1.default.object().keys({
    expression: joi_1.default.array().items(joi_1.default.string()).min(1).required(),
    cubeName: joi_1.default.string().required(),
    name: joi_1.default.string().required(),
    expressionName: joi_1.default.string(),
    definition: joi_1.default.string(),
    groupingSet: joi_1.default.object().keys({
        groupType: joi_1.default.valid('Rollup', 'Cube').required(),
        id: joi_1.default.number().required(),
        subId: joi_1.default.number()
    })
});
const memberExpression = parsedMemberExpression.keys({
    expression: joi_1.default.func().required(),
});
const operators = [
    'equals',
    'notEquals',
    'contains',
    'notContains',
    'startsWith',
    'notStartsWith',
    'endsWith',
    'notEndsWith',
    'in',
    'notIn',
    'gt',
    'gte',
    'lt',
    'lte',
    'set',
    'notSet',
    'inDateRange',
    'notInDateRange',
    'onTheDate',
    'beforeDate',
    'beforeOrOnDate',
    'afterDate',
    'afterOrOnDate',
    'measureFilter',
];
const oneFilter = joi_1.default.object().keys({
    dimension: id,
    member: id,
    operator: joi_1.default.valid(...operators).required(),
    values: joi_1.default.array().items(joi_1.default.string().allow('', null), joi_1.default.number(), joi_1.default.boolean(), joi_1.default.link('...'))
}).xor('dimension', 'member');
const oneCondition = joi_1.default.object().keys({
    or: joi_1.default.array().items(oneFilter, joi_1.default.link('...').description('oneCondition schema')),
    and: joi_1.default.array().items(oneFilter, joi_1.default.link('...').description('oneCondition schema')),
}).xor('or', 'and');
const querySchema = joi_1.default.object().keys({
    // TODO add member expression alternatives only for SQL API queries?
    measures: joi_1.default.array().items(joi_1.default.alternatives(id, memberExpression, parsedMemberExpression)),
    dimensions: joi_1.default.array().items(joi_1.default.alternatives(dimensionWithTime, memberExpression, parsedMemberExpression)),
    filters: joi_1.default.array().items(oneFilter, oneCondition),
    timeDimensions: joi_1.default.array().items(joi_1.default.object().keys({
        dimension: id.required(),
        granularity: joi_1.default.valid('quarter', 'day', 'month', 'year', 'week', 'hour', 'minute', 'second', null),
        dateRange: [
            joi_1.default.array().items(joi_1.default.string()).min(1).max(2),
            joi_1.default.string()
        ],
        compareDateRange: joi_1.default.array()
    }).oxor('dateRange', 'compareDateRange')),
    order: joi_1.default.alternatives(joi_1.default.object().pattern(idOrMemberExpressionName, joi_1.default.valid('asc', 'desc')), joi_1.default.array().items(joi_1.default.array().min(2).ordered(idOrMemberExpressionName, joi_1.default.valid('asc', 'desc')))),
    segments: joi_1.default.array().items(joi_1.default.alternatives(id, memberExpression, parsedMemberExpression)),
    timezone: joi_1.default.string(),
    limit: joi_1.default.number().integer().min(0),
    offset: joi_1.default.number().integer().min(0),
    total: joi_1.default.boolean(),
    renewQuery: joi_1.default.boolean(),
    ungrouped: joi_1.default.boolean(),
    responseFormat: joi_1.default.valid('default', 'compact'),
});
const normalizeQueryOrder = order => {
    let result = [];
    const normalizeOrderItem = (k, direction) => ([k, direction]);
    if (order) {
        result = Array.isArray(order) ?
            order.map(([k, direction]) => normalizeOrderItem(k, direction)) :
            Object.keys(order).map(k => normalizeOrderItem(k, order[k]));
    }
    return result;
};
const DateRegex = /^\d\d\d\d-\d\d-\d\d$/;
const normalizeQueryFilters = (filter) => (filter.map(f => {
    const res = { ...f };
    if (f.or) {
        res.or = normalizeQueryFilters(f.or);
        return res;
    }
    if (f.and) {
        res.and = normalizeQueryFilters(f.and);
        return res;
    }
    if (!f.operator) {
        throw new UserError_1.UserError(`Operator required for filter: ${JSON.stringify(f)}`);
    }
    if (operators.indexOf(f.operator) === -1) {
        throw new UserError_1.UserError(`Operator ${f.operator} not supported for filter: ${JSON.stringify(f)}`);
    }
    if ((!f.values || f.values.length === 0) && ['set', 'notSet', 'measureFilter'].indexOf(f.operator) === -1) {
        throw new UserError_1.UserError(`Values required for filter: ${JSON.stringify(f)}`);
    }
    if (f.values) {
        res.values = f.values.map(v => (v != null ? v.toString() : v));
    }
    if (f.dimension) {
        res.member = f.dimension;
        delete res.dimension;
    }
    return res;
}));
/**
 * Normalize incoming network query.
 * @param {Query} query
 * @param {boolean} persistent
 * @throws {UserError}
 * @returns {NormalizedQuery}
 */
const normalizeQuery = (query, persistent) => {
    const { error } = querySchema.validate(query);
    if (error) {
        throw new UserError_1.UserError(`Invalid query format: ${error.message || error.toString()}`);
    }
    const validQuery = query.measures && query.measures.length ||
        query.dimensions && query.dimensions.length ||
        query.timeDimensions && query.timeDimensions.filter(td => !!td.granularity).length;
    if (!validQuery) {
        throw new UserError_1.UserError('Query should contain either measures, dimensions or timeDimensions with granularities in order to be valid');
    }
    const regularToTimeDimension = (query.dimensions || []).filter(d => typeof d === 'string' && d.split('.').length === 3).map(d => ({
        dimension: d.split('.').slice(0, 2).join('.'),
        granularity: d.split('.')[2]
    }));
    const timezone = query.timezone || 'UTC';
    const def = (0, shared_1.getEnv)('dbQueryDefaultLimit') <= (0, shared_1.getEnv)('dbQueryLimit')
        ? (0, shared_1.getEnv)('dbQueryDefaultLimit')
        : (0, shared_1.getEnv)('dbQueryLimit');
    let newLimit;
    if (!persistent) {
        if (typeof query.limit === 'number' &&
            query.limit > (0, shared_1.getEnv)('dbQueryLimit')) {
            throw new Error('The query limit has been exceeded.');
        }
        newLimit = typeof query.limit === 'number'
            ? query.limit
            : def;
    }
    else {
        newLimit = query.limit;
    }
    return {
        ...query,
        ...(query.order ? { order: normalizeQueryOrder(query.order) } : {}),
        limit: newLimit,
        timezone,
        filters: normalizeQueryFilters(query.filters || []),
        dimensions: (query.dimensions || []).filter(d => typeof d !== 'string' || d.split('.').length !== 3),
        timeDimensions: (query.timeDimensions || []).map(td => {
            let dateRange;
            const compareDateRange = td.compareDateRange ? td.compareDateRange.map((currentDateRange) => (typeof currentDateRange === 'string' ? (0, dateParser_1.dateParser)(currentDateRange, timezone) : currentDateRange)) : null;
            if (typeof td.dateRange === 'string') {
                dateRange = (0, dateParser_1.dateParser)(td.dateRange, timezone);
            }
            else {
                dateRange = td.dateRange && td.dateRange.length === 1 ? [td.dateRange[0], td.dateRange[0]] : td.dateRange;
            }
            return {
                ...td,
                dateRange: dateRange && dateRange.map((d, i) => (i === 0 ?
                    moment_1.default.utc(d).format(d.match(DateRegex) ? 'YYYY-MM-DDT00:00:00.000' : moment_1.default.HTML5_FMT.DATETIME_LOCAL_MS) :
                    moment_1.default.utc(d).format(d.match(DateRegex) ? 'YYYY-MM-DDT23:59:59.999' : moment_1.default.HTML5_FMT.DATETIME_LOCAL_MS))),
                ...(compareDateRange ? { compareDateRange } : {})
            };
        }).concat(regularToTimeDimension)
    };
};
exports.normalizeQuery = normalizeQuery;
const remapQueryOrder = order => {
    let result = [];
    const normalizeOrderItem = (k, direction) => ({
        id: k,
        desc: direction === 'desc'
    });
    if (order) {
        result = Array.isArray(order) ?
            order.map(([k, direction]) => normalizeOrderItem(k, direction)) :
            Object.keys(order).map(k => normalizeOrderItem(k, order[k]));
    }
    return result;
};
const remapToQueryAdapterFormat = (query) => (query ? {
    ...query,
    rowLimit: query.limit,
    ...(query.order ? { order: remapQueryOrder(query.order) } : {}),
} : query);
exports.remapToQueryAdapterFormat = remapToQueryAdapterFormat;
const queryPreAggregationsSchema = joi_1.default.object().keys({
    expand: joi_1.default.array().items(joi_1.default.string()),
    metadata: joi_1.default.object(),
    timezone: joi_1.default.string(),
    timezones: joi_1.default.array().items(joi_1.default.string()),
    preAggregations: joi_1.default.array().items(joi_1.default.object().keys({
        id: joi_1.default.string().required(),
        cacheOnly: joi_1.default.boolean(),
        partitions: joi_1.default.array().items(joi_1.default.string()),
        refreshRange: joi_1.default.array().items(joi_1.default.string()).length(2), // TODO: Deprecate after cloud changes
    }))
});
const normalizeQueryPreAggregations = (query, defaultValues) => {
    const { error } = queryPreAggregationsSchema.validate(query);
    if (error) {
        throw new UserError_1.UserError(`Invalid query format: ${error.message || error.toString()}`);
    }
    return {
        metadata: query.metadata,
        timezones: query.timezones || (query.timezone && [query.timezone]) || defaultValues?.timezones || ['UTC'],
        preAggregations: query.preAggregations,
        expand: query.expand
    };
};
exports.normalizeQueryPreAggregations = normalizeQueryPreAggregations;
const queryPreAggregationPreviewSchema = joi_1.default.object().keys({
    preAggregationId: joi_1.default.string().required(),
    timezone: joi_1.default.string().required(),
    versionEntry: joi_1.default.object().required().keys({
        content_version: joi_1.default.string(),
        last_updated_at: joi_1.default.number(),
        naming_version: joi_1.default.number(),
        structure_version: joi_1.default.string(),
        table_name: joi_1.default.string(),
        build_range_end: joi_1.default.string(),
    })
});
const normalizeQueryPreAggregationPreview = (query) => {
    const { error } = queryPreAggregationPreviewSchema.validate(query);
    if (error) {
        throw new UserError_1.UserError(`Invalid query format: ${error.message || error.toString()}`);
    }
    return query;
};
exports.normalizeQueryPreAggregationPreview = normalizeQueryPreAggregationPreview;
const queryCancelPreAggregationPreviewSchema = joi_1.default.object().keys({
    dataSource: joi_1.default.string(),
    queryKeys: joi_1.default.array().items(joi_1.default.string())
});
const normalizeQueryCancelPreAggregations = query => {
    const { error } = queryCancelPreAggregationPreviewSchema.validate(query);
    if (error) {
        throw new UserError_1.UserError(`Invalid query format: ${error.message || error.toString()}`);
    }
    return query;
};
exports.normalizeQueryCancelPreAggregations = normalizeQueryCancelPreAggregations;
//# sourceMappingURL=query.js.map