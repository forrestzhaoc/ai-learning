"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScaffoldingSchema = exports.MemberType = void 0;
const inflection_1 = __importDefault(require("inflection"));
const ramda_1 = __importDefault(require("ramda"));
const compiler_1 = require("../compiler");
const utils_1 = require("./utils");
var ColumnType;
(function (ColumnType) {
    ColumnType["Time"] = "time";
    ColumnType["Number"] = "number";
    ColumnType["String"] = "string";
    ColumnType["Boolean"] = "boolean";
})(ColumnType || (ColumnType = {}));
var MemberType;
(function (MemberType) {
    MemberType["Measure"] = "measure";
    MemberType["Dimension"] = "dimension";
    MemberType["None"] = "none";
})(MemberType || (exports.MemberType = MemberType = {}));
const MEASURE_DICTIONARY = [
    'amount',
    'price',
    'count',
    'balance',
    'total',
    'number',
    'cost',
    'qty',
    'quantity',
    'duration',
    'value',
];
const idRegex = '_id$|id$';
class ScaffoldingSchema {
    constructor(dbSchema, options = {}) {
        this.dbSchema = dbSchema;
        this.options = options;
        this.tableNamesToTables = {};
    }
    resolveTableName(tableName) {
        let tableParts;
        if (Array.isArray(tableName)) {
            tableParts = tableName;
        }
        else {
            tableParts = tableName.match(/(["`].*?["`]|[^`".]+)+(?=\s*|\s*$)/g);
        }
        if (tableParts.length === 2) {
            this.resolveTableDefinition(tableName);
            return tableName;
        }
        else if (tableParts.length === 1 && typeof tableName === 'string') {
            const schema = Object.keys(this.dbSchema).find((tableSchema) => this.dbSchema[tableSchema][tableName] ||
                this.dbSchema[tableSchema][inflection_1.default.tableize(tableName)]);
            if (!schema) {
                throw new compiler_1.UserError(`Can't find any table with '${tableName}' name`);
            }
            if (this.dbSchema[schema][tableName]) {
                return `${schema}.${tableName}`;
            }
            if (this.dbSchema[schema][inflection_1.default.tableize(tableName)]) {
                return `${schema}.${inflection_1.default.tableize(tableName)}`;
            }
        }
        throw new compiler_1.UserError('Table names should be in <table> or <schema>.<table> format');
    }
    cubeDescriptors(tableNames) {
        const cubes = this.generateForTables(tableNames);
        function member(type) {
            return (value) => ({
                memberType: type,
                ...ramda_1.default.pick(['name', 'title', 'types', 'isPrimaryKey', 'included', 'isId'], value)
            });
        }
        return cubes.map((cube) => ({
            cube: cube.cube,
            tableName: cube.tableName,
            table: cube.table,
            schema: cube.schema,
            members: (cube.measures || []).map(member(MemberType.Measure))
                .concat((cube.dimensions || []).map(member(MemberType.Dimension))),
            joins: cube.joins
        }));
    }
    generateForTables(tableNames) {
        this.prepareTableNamesToTables(tableNames);
        return tableNames.map(tableName => this.tableSchema(tableName, true));
    }
    prepareTableNamesToTables(tableNames) {
        this.tableNamesToTables = ramda_1.default.pipe(
        // @ts-ignore
        ramda_1.default.unnest, ramda_1.default.groupBy(n => n[0]), ramda_1.default.map(groupedNameToDef => groupedNameToDef.map(nameToDef => nameToDef[1])))(
        // @ts-ignore
        tableNames.map(tableName => {
            const [schema, table] = this.parseTableName(tableName);
            const tableDefinition = this.resolveTableDefinition(tableName);
            const definition = {
                schema, table, tableDefinition, tableName
            };
            const tableizeName = inflection_1.default.tableize(this.fixCase(table));
            const parts = tableizeName.split('_');
            const tableNamesFromParts = ramda_1.default.range(0, parts.length - 1).map(toDrop => inflection_1.default.tableize(ramda_1.default.drop(toDrop, parts).join('_')));
            const names = ramda_1.default.uniq([table, tableizeName].concat(tableNamesFromParts));
            return names.map(n => [n, definition]);
        }));
    }
    resolveTableDefinition(tableName) {
        const [schema, table] = this.parseTableName(tableName);
        if (!this.dbSchema[schema]) {
            throw new compiler_1.UserError(`Can't resolve ${tableName}: '${schema}' does not exist`);
        }
        if (!this.dbSchema[schema][table]) {
            throw new compiler_1.UserError(`Can't resolve ${tableName}: '${table}' does not exist`);
        }
        return this.dbSchema[schema][table];
    }
    tableSchema(tableName, includeJoins) {
        const [schema, table] = this.parseTableName(tableName);
        const tableDefinition = this.resolveTableDefinition(tableName);
        const dimensions = this.dimensions(tableDefinition);
        return {
            cube: this.options.snakeCase ? (0, utils_1.toSnakeCase)(table) : inflection_1.default.camelize(table),
            tableName,
            schema,
            table,
            measures: this.numberMeasures(tableDefinition),
            dimensions,
            joins: includeJoins ? this.joins(tableName, tableDefinition) : []
        };
    }
    parseTableName(tableName) {
        let schemaAndTable;
        if (Array.isArray(tableName)) {
            schemaAndTable = tableName;
        }
        else {
            schemaAndTable = tableName.match(/(["`].*?["`]|[^`".]+)+(?=\s*|\s*$)/g);
        }
        if (schemaAndTable.length !== 2) {
            throw new compiler_1.UserError(`Incorrect format for '${tableName}'. Should be in '<schema>.<table>' format`);
        }
        return schemaAndTable;
    }
    dimensions(tableDefinition) {
        return this.dimensionColumns(tableDefinition).map(column => {
            const res = {
                name: column.name,
                types: [column.columnType || this.columnType(column)],
                title: inflection_1.default.titleize(column.name),
            };
            if (column.columnType !== 'time') {
                res.isPrimaryKey = column.attributes?.includes('primaryKey') ||
                    this.fixCase(column.name) === 'id';
            }
            return res;
        });
    }
    numberMeasures(tableDefinition) {
        return tableDefinition.filter(column => (!column.name.startsWith('_') &&
            (this.columnType(column) === 'number') &&
            (this.options.includeNonDictionaryMeasures ? this.fixCase(column.name) !== 'id' : this.fromMeasureDictionary(column)))).map(column => ({
            name: column.name,
            types: ['sum', 'avg', 'min', 'max'],
            title: inflection_1.default.titleize(column.name),
            ...(this.options.includeNonDictionaryMeasures ? { included: this.fromMeasureDictionary(column) } : null)
        }));
    }
    fromMeasureDictionary(column) {
        return !column.name.match(new RegExp(idRegex, 'i')) && !!MEASURE_DICTIONARY.find(word => this.fixCase(column.name).endsWith(word));
    }
    dimensionColumns(tableDefinition) {
        const dimensionColumns = tableDefinition.filter(column => !column.name.startsWith('_') && ['string', 'boolean'].includes(this.columnType(column)) ||
            column.attributes?.includes('primaryKey') ||
            this.fixCase(column.name) === 'id');
        const timeColumns = ramda_1.default.pipe(
        // @ts-ignore
        ramda_1.default.filter(column => !column.name.startsWith('_') && this.columnType(column) === 'time'), ramda_1.default.sortBy(column => this.timeColumnIndex(column)), 
        // @ts-ignore
        ramda_1.default.map(column => ({ ...column, columnType: 'time' })) // TODO do we need it?
        // @ts-ignore
        )(tableDefinition);
        return dimensionColumns.concat(timeColumns);
    }
    fixCase(value) {
        if (this.options.snakeCase) {
            return (0, utils_1.toSnakeCase)(value);
        }
        return value.toLocaleLowerCase();
    }
    joins(tableName, tableDefinition) {
        const cubeName = (name) => (this.options.snakeCase ? (0, utils_1.toSnakeCase)(name) : inflection_1.default.camelize(name));
        return ramda_1.default.unnest(tableDefinition
            .map(column => {
            let columnsToJoin = [];
            if (column.foreign_keys?.length) {
                column.foreign_keys.forEach(fk => {
                    const targetTableDefinition = this.tableNamesToTables[fk.target_table]?.find(t => t.table === fk.target_table);
                    if (targetTableDefinition) {
                        columnsToJoin.push({
                            cubeToJoin: cubeName(fk.target_table),
                            columnToJoin: fk.target_column,
                            tableName: targetTableDefinition.tableName
                        });
                    }
                });
            }
            else if ((column.name.match(new RegExp(idRegex, 'i')) && this.fixCase(column.name) !== 'id')) {
                const withoutId = column.name.replace(new RegExp(idRegex, 'i'), '');
                const tablesToJoin = this.tableNamesToTables[withoutId] ||
                    this.tableNamesToTables[inflection_1.default.tableize(withoutId)] ||
                    this.tableNamesToTables[this.fixCase(withoutId)] ||
                    this.tableNamesToTables[(inflection_1.default.tableize(this.fixCase(withoutId)))];
                if (!tablesToJoin) {
                    return null;
                }
                columnsToJoin = tablesToJoin.map(definition => {
                    if (tableName === definition.tableName) {
                        return null;
                    }
                    let columnForJoin = definition.tableDefinition.find(c => this.fixCase(c.name) === this.fixCase(column.name));
                    columnForJoin = columnForJoin || definition.tableDefinition.find(c => this.fixCase(c.name) === 'id');
                    if (!columnForJoin) {
                        return null;
                    }
                    return {
                        cubeToJoin: cubeName(definition.table),
                        columnToJoin: columnForJoin.name,
                        tableName: definition.tableName
                    };
                }).filter(ramda_1.default.identity);
            }
            if (!columnsToJoin.length) {
                return null;
            }
            return columnsToJoin.map(columnToJoin => ({
                thisTableColumn: column.name,
                tableName: columnToJoin.tableName,
                cubeToJoin: columnToJoin.cubeToJoin,
                columnToJoin: columnToJoin.columnToJoin,
                relationship: 'belongsTo'
            }));
        })
            .filter(ramda_1.default.identity));
    }
    timeColumnIndex(column) {
        const name = this.fixCase(column.name);
        if (name.indexOf('create') !== -1) {
            return 0;
        }
        else if (name.indexOf('update') !== -1) {
            return 1;
        }
        else {
            return 2;
        }
    }
    columnType(column) {
        const type = this.fixCase(column.type);
        if (['time', 'date'].find(t => type.includes(t))) {
            return ColumnType.Time;
        }
        else if (['int', 'dec', 'double', 'numb'].find(t => type.includes(t))) {
            // enums are not Numbers
            return ColumnType.Number;
        }
        else if (['bool'].find(t => type.includes(t))) {
            return ColumnType.Boolean;
        }
        return ColumnType.String;
    }
}
exports.ScaffoldingSchema = ScaffoldingSchema;
//# sourceMappingURL=ScaffoldingSchema.js.map