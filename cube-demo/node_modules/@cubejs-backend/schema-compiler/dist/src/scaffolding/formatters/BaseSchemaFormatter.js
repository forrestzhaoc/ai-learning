"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSchemaFormatter = void 0;
const inflection_1 = __importDefault(require("inflection"));
const ScaffoldingSchema_1 = require("../ScaffoldingSchema");
const ValueWithComments_1 = require("../descriptors/ValueWithComments");
const utils_1 = require("../utils");
const JOIN_RELATIONSHIP_MAP = {
    hasOne: 'one_to_one',
    hasMany: 'one_to_many',
    belongsTo: 'many_to_one',
};
class BaseSchemaFormatter {
    constructor(dbSchema, driver, options) {
        this.dbSchema = dbSchema;
        this.driver = driver;
        this.options = options;
        this.scaffoldingSchema = new ScaffoldingSchema_1.ScaffoldingSchema(dbSchema, this.options);
    }
    generateFilesByTableNames(tableNames, schemaContext = {}) {
        const schemaForTables = this.scaffoldingSchema.generateForTables(tableNames.map((n) => this.scaffoldingSchema.resolveTableName(n)));
        return schemaForTables.map((tableSchema) => ({
            fileName: `${tableSchema.cube}.${this.fileExtension()}`,
            content: this.renderFile(this.schemaDescriptorForTable(tableSchema, schemaContext)),
        }));
    }
    generateFilesByCubeDescriptors(cubeDescriptors, schemaContext = {}) {
        return this.schemaForTablesByCubeDescriptors(cubeDescriptors).map((tableSchema) => ({
            fileName: `${tableSchema.cube}.${this.fileExtension()}`,
            content: this.renderFile(this.schemaDescriptorForTable(tableSchema, schemaContext)),
        }));
    }
    sqlForMember(m) {
        return `${this.escapeName(m.name) !== m.name || !this.eligibleIdentifier(m.name)
            ? `${this.cubeReference('CUBE')}.`
            : ''}${this.escapeName(m.name)}`;
    }
    memberTitle(m) {
        return inflection_1.default.titleize(inflection_1.default.underscore(this.memberName(m))) !== m.title
            ? m.title
            : undefined;
    }
    memberName(member) {
        const title = member.title.replace(/[^A-Za-z0-9]+/g, '_').toLowerCase();
        if (this.options.snakeCase) {
            return (0, utils_1.toSnakeCase)(title);
        }
        return inflection_1.default.camelize(title, true);
    }
    escapeName(name) {
        if (this.eligibleIdentifier(name)) {
            return name;
        }
        return this.driver.quoteIdentifier(name);
    }
    eligibleIdentifier(name) {
        return !!name.match(/^[a-z0-9_]+$/);
    }
    schemaDescriptorForTable(tableSchema, schemaContext = {}) {
        let table = `${tableSchema.schema?.length ? `${this.escapeName(tableSchema.schema)}.` : ''}${this.escapeName(tableSchema.table)}`;
        if (this.options.catalog) {
            table = `${this.escapeName(this.options.catalog)}.${table}`;
        }
        const { dataSource, ...contextProps } = schemaContext;
        let dataSourceProp = {};
        if (dataSource) {
            dataSourceProp = this.options.snakeCase ? { data_source: dataSource } : { dataSource };
        }
        const sqlOption = this.options.snakeCase
            ? {
                sql_table: table,
            }
            : {
                sql: `SELECT * FROM ${table}`,
            };
        return {
            cube: tableSchema.cube,
            ...sqlOption,
            ...dataSourceProp,
            joins: tableSchema.joins
                .map((j) => ({
                [j.cubeToJoin]: {
                    sql: `${this.cubeReference('CUBE')}.${this.escapeName(j.thisTableColumn)} = ${this.cubeReference(j.cubeToJoin)}.${this.escapeName(j.columnToJoin)}`,
                    relationship: this.options.snakeCase
                        ? JOIN_RELATIONSHIP_MAP[j.relationship]
                        : j.relationship,
                },
            }))
                .reduce((a, b) => ({ ...a, ...b }), {}),
            dimensions: tableSchema.dimensions.sort((a) => (a.isPrimaryKey ? -1 : 0))
                .map((m) => ({
                [this.memberName(m)]: {
                    sql: this.sqlForMember(m),
                    type: m.type ?? m.types[0],
                    title: this.memberTitle(m),
                    [this.options.snakeCase ? 'primary_key' : 'primaryKey']: m.isPrimaryKey
                        ? true
                        : undefined,
                },
            }))
                .reduce((a, b) => ({ ...a, ...b }), {}),
            measures: tableSchema.measures
                .map((m) => ({
                [this.memberName(m)]: {
                    sql: this.sqlForMember(m),
                    type: m.type ?? m.types[0],
                    title: this.memberTitle(m),
                },
            }))
                .reduce((a, b) => ({ ...a, ...b }), {
                count: {
                    type: 'count',
                },
            }),
            ...(this.options.snakeCase
                ? Object.fromEntries(Object.entries(contextProps).map(([key, value]) => [(0, utils_1.toSnakeCase)(key), value]))
                : contextProps),
            [this.options.snakeCase ? 'pre_aggregations' : 'preAggregations']: new ValueWithComments_1.ValueWithComments(null, [
                'Pre-aggregation definitions go here.',
                'Learn more in the documentation: https://cube.dev/docs/caching/pre-aggregations/getting-started',
            ]),
        };
    }
    schemaForTablesByCubeDescriptors(cubeDescriptors) {
        const tableNames = cubeDescriptors.map(({ tableName }) => tableName);
        const generatedSchemaForTables = this.scaffoldingSchema.generateForTables(tableNames.map((n) => this.scaffoldingSchema.resolveTableName(n)));
        return cubeDescriptors.map((descriptor) => {
            const generatedDescriptor = generatedSchemaForTables.find(({ cube }) => cube === descriptor.cube);
            const cubeMembers = descriptor.members.reduce((memo, member) => ({
                measures: [...memo.measures].concat(member.memberType === ScaffoldingSchema_1.MemberType.Measure ? [member] : []),
                dimensions: [...memo.dimensions].concat(member.memberType === ScaffoldingSchema_1.MemberType.Dimension ? [member] : []),
            }), {
                measures: [],
                dimensions: [],
            });
            return {
                ...generatedDescriptor,
                ...descriptor,
                ...cubeMembers,
            };
        });
    }
}
exports.BaseSchemaFormatter = BaseSchemaFormatter;
//# sourceMappingURL=BaseSchemaFormatter.js.map