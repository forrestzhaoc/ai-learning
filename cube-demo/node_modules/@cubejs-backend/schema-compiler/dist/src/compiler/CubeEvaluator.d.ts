import { CubeSymbols } from './CubeSymbols';
import type { CubeValidator } from './CubeValidator';
import type { ErrorReporter } from './ErrorReporter';
export type SegmentDefinition = {
    type: string;
    sql: Function;
    primaryKey?: true;
    ownedByCube: boolean;
    fieldType?: string;
    postAggregate?: boolean;
};
export type DimensionDefinition = {
    type: string;
    sql: Function;
    primaryKey?: true;
    ownedByCube: boolean;
    fieldType?: string;
    postAggregate?: boolean;
    shiftInterval?: string;
};
export type TimeShiftDefinition = {
    timeDimension: Function;
    interval: string;
    type: 'next' | 'prior';
};
export type TimeShiftDefinitionReference = {
    timeDimension: string;
    interval: string;
    type: 'next' | 'prior';
};
export type MeasureDefinition = {
    type: string;
    sql: Function;
    ownedByCube: boolean;
    rollingWindow?: any;
    filters?: any;
    primaryKey?: true;
    drillFilters?: any;
    postAggregate?: boolean;
    groupBy?: Function;
    reduceBy?: Function;
    addGroupBy?: Function;
    timeShift?: TimeShiftDefinition[];
    groupByReferences?: string[];
    reduceByReferences?: string[];
    addGroupByReferences?: string[];
    timeShiftReferences?: TimeShiftDefinitionReference[];
};
export declare class CubeEvaluator extends CubeSymbols {
    protected readonly cubeValidator: CubeValidator;
    evaluatedCubes: Record<string, any>;
    primaryKeys: Record<string, any>;
    byFileName: Record<string, any>;
    constructor(cubeValidator: CubeValidator);
    compile(cubes: any[], errorReporter: ErrorReporter): void;
    protected prepareCube(cube: any, errorReporter: ErrorReporter): any;
    private prepareHierarchies;
    private evaluatePostAggregateReferences;
    protected prepareJoins(cube: any, _errorReporter: ErrorReporter): void;
    protected preparePreAggregations(cube: any, errorReporter: ErrorReporter): void;
    protected prepareMembers(members: any, cube: any, errorReporter: ErrorReporter): void;
    cubesByFileName(fileName: any): any;
    timeDimensionPathsForCube(cube: any): string[];
    measuresForCube(cube: any): any;
    preAggregationsForCube(path: string): any;
    /**
     * Returns pre-aggregations filtered by the spcified selector.
     * @param {{
     *  scheduled: boolean,
     *  dataSource: Array<string>,
     *  cubes: Array<string>,
     *  preAggregationIds: Array<string>
     * }} filter pre-aggregations selector
     * @returns {*}
     */
    preAggregations(filter: any): {
        id: string;
        preAggregationName: string;
        preAggregation: any;
        cube: string;
        references: {
            allowNonStrictDateRangeMatch: any;
            dimensions: any;
            measures: any;
            timeDimensions: any;
            rollups: any;
        };
        refreshKey: any;
        indexesReferences: any;
    }[];
    scheduledPreAggregations(): {
        id: string;
        preAggregationName: string;
        preAggregation: any;
        cube: string;
        references: {
            allowNonStrictDateRangeMatch: any;
            dimensions: any;
            measures: any;
            timeDimensions: any;
            rollups: any;
        };
        refreshKey: any;
        indexesReferences: any;
    }[];
    cubeNames(): string[];
    isMeasure(measurePath: string): boolean;
    isDimension(path: string): boolean;
    isSegment(path: string): boolean;
    measureByPath(measurePath: string): MeasureDefinition;
    dimensionByPath(dimensionPath: string): DimensionDefinition;
    segmentByPath(segmentPath: string): SegmentDefinition;
    cubeExists(cube: any): boolean;
    cubeFromPath(path: string): any;
    cubeNameFromPath(path: string): string;
    isInstanceOfType(type: 'measures' | 'dimensions' | 'segments', path: string | string[]): boolean;
    byPathAnyType(path: string[]): any;
    byPath(type: 'measures' | 'dimensions' | 'segments', path: string | string[]): any;
    parsePath(type: any, path: any): any;
    protected parsePathAnyType(path: any): any;
    collectUsedCubeReferences(cube: any, sqlFn: any): {
        cubeReferencesUsed: string[];
        pathReferencesUsed: string[][];
        evaluatedSql: any;
    };
    protected evaluatePreAggregationReferences(cube: any, aggregation: any): {
        allowNonStrictDateRangeMatch: any;
        dimensions: any;
        measures: any;
        timeDimensions: any;
        rollups: any;
    };
}
//# sourceMappingURL=CubeEvaluator.d.ts.map