import { BaseQuery } from './BaseQuery';
import { ParamAllocator } from './ParamAllocator';
declare class MssqlParamAllocator extends ParamAllocator {
    paramPlaceHolder(paramIndex: any): string;
}
export declare class MssqlQuery extends BaseQuery {
    newFilter(filter: any): any;
    castToString(sql: any): string;
    concatStringsSql(strings: string[]): string;
    convertTz(field: any): string;
    timeStampCast(value: any): string;
    dateTimeCast(value: any): string;
    timeGroupedColumn(granularity: any, dimension: any): any;
    newParamAllocator(expressionParams: any): MssqlParamAllocator;
    groupByDimensionLimit(): string;
    topLimit(): string;
    /**
     * Overrides `BaseQuery#groupByClause` method and returns `GROUP BY` clause
     * with the column names instead of column numeric sequences as MSSQL does
     * not support this format.
     * @returns {string}
     * @override
     */
    groupByClause(): string;
    /**
     * Overrides `BaseQuery#aggregateSubQueryGroupByClause` method and returns
     * `GROUP BY` clause for the "aggregating on top of sub-queries" uses cases.
     * @returns {string}
     * @override
     */
    aggregateSubQueryGroupByClause(): string;
    overTimeSeriesSelect(cumulativeMeasures: any, dateSeriesSql: any, baseQuery: any, dateJoinConditionSql: any, baseQueryAlias: any): string;
    nowTimestampSql(): string;
    unixTimestampSql(): string;
    preAggregationLoadSql(cube: any, preAggregation: any, tableName: any): any[];
    wrapSegmentForDimensionSelect(sql: any): string;
    seriesSql(timeDimension: any): string;
    subtractInterval(date: any, interval: any): string;
    addInterval(date: any, interval: any): string;
    sqlTemplates(): any;
}
export {};
//# sourceMappingURL=MssqlQuery.d.ts.map