/**
 * Set of the schema compilers.
 * @typedef {Object} Compilers
 * @property {import('../compiler/DataSchemaCompiler').DataSchemaCompiler} compiler
 * @property {import('../compiler/CubeToMetaTransformer').CubeToMetaTransformer} metaTransformer
 * @property {import('../compiler/CubeEvaluator').CubeEvaluator} cubeEvaluator
 * @property {import('../compiler/ContextEvaluator').ContextEvaluator} contextEvaluator
 * @property {import('../compiler/JoinGraph').JoinGraph} joinGraph
 * @property {import('../compiler/CompilerCache').CompilerCache} compilerCache
 * @property {*} headCommitId
 */
/**
 * BaseQuery class. BaseQuery object encapsulates the logic of
 * transforming an incoming to a specific cube request to the
 * SQL-query string.
 *
 * This class is a parent class for the set of dialect specific
 * query adapters (for ex. MysqlQuery, OracleQuery, etc.).
 *
 * You should never instantiate this class manually. Instead, you
 * should use {@code CompilerApi#getDialectClass} method, which
 * should return query object based on the datasource, database type
 * and {@code CompilerApi} configuration.
 */
export class BaseQuery {
    static isCalculatedMeasureType(type: any): boolean;
    /**
     TODO: support type qualifiers on min and max
    */
    static toMemberDataType(type: any): any;
    static emptyParametrizedContextSymbols(cubeEvaluator: any, allocateParam: any): {
        filterParams: {};
        filterGroup: () => string;
        sqlUtils: {
            convertTz: (field: any) => any;
        };
        securityContext: any;
    };
    static contextSymbolsProxyFrom(symbols: any, allocateParam: any): any;
    static extractFilterMembers(filter: any): any;
    static findAndSubTreeForFilterGroup(filter: any, groupMembers: any, newGroupFilter: any, aliases: any): any;
    static renderFilterParams(filter: any, filterParamArgs: any, allocateParam: any, newGroupFilter: any, aliases: any): any;
    static filterProxyFromAllFilters(allFilters: any, cubeEvaluator: any, allocateParam: any, newGroupFilter: any): {};
    /**
     * BaseQuery class constructor.
     * @param {Compilers|*} compilers
     * @param {*} options
     */
    constructor(compilers: Compilers | any, options: any);
    compilers: any;
    /** @type {import('../compiler/CubeEvaluator').CubeEvaluator} */
    cubeEvaluator: import('../compiler/CubeEvaluator').CubeEvaluator;
    /** @type {import('../compiler/JoinGraph').JoinGraph} */
    joinGraph: import('../compiler/JoinGraph').JoinGraph;
    options: any;
    orderHashToString(hash: any): string | null;
    defaultOrder(): {
        id: any;
        desc: boolean;
    }[];
    /** @type {ParamAllocator} */
    paramAllocator: ParamAllocator;
    extractDimensionsAndMeasures(filters?: any[]): any[];
    keepFilters(filters: any[] | undefined, fn: any): any;
    extractFiltersAsTree(filters?: any[]): any;
    /**
     * @protected
     */
    protected initFromOptions(): void;
    contextSymbols: any;
    compilerCache: any;
    queryCache: any;
    from: any;
    postAggregateQuery: any;
    timezone: any;
    rowLimit: any;
    offset: any;
    preAggregations: PreAggregations | undefined;
    measures: any;
    dimensions: any;
    postAggregateDimensions: any;
    postAggregateTimeDimensions: any;
    segments: any;
    /** @type {(BaseFilter|BaseGroupFilter)[]} */
    filters: (BaseFilter | BaseGroupFilter)[] | undefined;
    measureFilters: any;
    timeDimensions: any;
    allFilters: any;
    join: any;
    cubeAliasPrefix: any;
    preAggregationsSchemaOption: any;
    externalQueryClass: any;
    order: any;
    cacheValue(key: any, fn: any, { contextPropNames, inputProps, cache }?: {
        contextPropNames: any;
        inputProps: any;
        cache: any;
    }): any;
    get allCubeNames(): any;
    collectedCubeNames: any;
    get allJoinHints(): any;
    collectedJoinHints: any;
    get dataSource(): any;
    cubeDataSource(cube: any): any;
    get aliasNameToMember(): {
        [index: string]: any;
    };
    initUngrouped(): void;
    ungrouped: any;
    get subQueryDimensions(): any;
    _subQueryDimensions: any;
    get asSyntaxTable(): string;
    get asSyntaxJoin(): string;
    newMeasure(measurePath: any): BaseMeasure;
    newDimension(dimensionPath: any): BaseDimension;
    newSegment(segmentPath: any): BaseSegment;
    /**
     * @returns {BaseGroupFilter|BaseFilter}
     */
    initFilter(filter: any): BaseGroupFilter | BaseFilter;
    /**
     * @returns {BaseFilter}
     */
    newFilter(filter: any): BaseFilter;
    newGroupFilter(filter: any): BaseGroupFilter;
    /**
     * @param timeDimension
     * @return {BaseTimeDimension}
     */
    newTimeDimension(timeDimension: any): BaseTimeDimension;
    newParamAllocator(expressionParams: any): ParamAllocator;
    newPreAggregations(): PreAggregations;
    /**
     * Wrap specified column/table name with the double quote.
     * @param {string} name
     * @returns {string}
     */
    escapeColumnName(name: string): string;
    /**
     * Returns SQL query string.
     * @returns {string}
     */
    buildParamAnnotatedSql(): string;
    /**
     * Generate SQL query to calculate total number of rows of the
     * specified SQL query.
     * @param {string} sql
     * @returns {string}
     */
    countAllQuery(sql: string): string;
    regularAndTimeSeriesRollupQuery(regularMeasures: any, multipliedMeasures: any, cumulativeMeasures: any, preAggregationForQuery: any): string;
    externalPreAggregationQuery(): boolean;
    /**
     * Returns an array of SQL query strings for the query.
     * @param {boolean} [exportAnnotatedSql] - returns annotated sql with not rendered params if true
     * @returns {Array<string>}
     */
    buildSqlAndParams(exportAnnotatedSql?: boolean | undefined): Array<string>;
    buildSqlAndParamsRust(exportAnnotatedSql: any): String;
    get shouldReuseParams(): boolean;
    /**
     * Returns a dictionary mapping each preagregation to its corresponding query fragment.
     * @returns {Record<string, Array<string>>}
     */
    buildLambdaQuery(): Record<string, Array<string>>;
    externalQuery(): any;
    runningTotalDateJoinCondition(): any;
    rollingWindowToDateJoinCondition(granularity: any): any;
    rollingWindowDateJoinCondition(trailingInterval: any, leadingInterval: any, offset: any): any;
    subtractInterval(date: any, interval: any): string;
    addInterval(date: any, interval: any): string;
    addTimestampInterval(timestamp: any, interval: any): string;
    subtractTimestampInterval(timestamp: any, interval: any): string;
    cumulativeMeasures(): any;
    isRolling(): boolean;
    simpleQuery(): string;
    /**
     * Returns SQL query string.
     * @returns {string}
     */
    fullKeyQueryAggregate(): string;
    joinFullKeyQueryAggregate(multipliedMeasures: any, regularMeasures: any, cumulativeMeasures: any, toJoin: any): string;
    outerMeasuresJoinFullKeyQueryAggregate(innerMembers: any, outerMembers: any, toJoin: any): string;
    wrapInParenthesis(select: any): any;
    withQueries(select: any, withQueries: any): any;
    fullKeyQueryAggregateMeasures(context: any): {
        multipliedMeasures: BaseMeasure[];
        regularMeasures: BaseMeasure[];
        cumulativeMeasures: R.KeyValuePair<any, BaseMeasure>[];
        postAggregateMembers: any[];
        withQueries: any[];
    };
    collectAllMemberChildren(context: any): any;
    collectAllPostAggregateMembers(allMemberChildren: any): {
        [index: string]: any;
    };
    memberInstanceByPath(m: any): BaseMeasure | BaseDimension | BaseSegment;
    postAggregateWithQueries(member: any, queryContext: any, memberChildren: any, withQueries: any): any;
    collectUsedWithQueries(usedQueries: any, member: any): void;
    childrenPostAggregateContext(memberPath: any, queryContext: any, wouldNodeApplyFilters: any): any;
    selfPostAggregateContext(memberPath: any, queryContext: any, wouldNodeApplyFilters: any): any;
    renderWithQuery(withQuery: any): {
        query: any;
        alias: any;
    };
    dimensionsJoinCondition(leftAlias: any, rightAlias: any): string;
    baseWhere(filters: any): string;
    baseHaving(filters: any): string;
    timeStampInClientTz(dateParam: any): string;
    granularityHierarchies(): {
        [index: string]: any;
    };
    granularityParentHierarchy(granularity: any): any;
    minGranularity(granularityA: any, granularityB: any): any;
    overTimeSeriesQuery(baseQueryFn: any, cumulativeMeasure: any, fromRollup: any): any;
    dateFromStartToEndConditionSql(dateJoinCondition: any, fromRollup: any, isFromStartToEnd: any): any;
    overTimeSeriesSelect(cumulativeMeasures: any, dateSeriesSql: any, baseQuery: any, dateJoinConditionSql: any, baseQueryAlias: any): string;
    overTimeSeriesForSelect(cumulativeMeasures: any): any;
    dateSeriesSelect(): any;
    /**
     * @param {import('./BaseTimeDimension').BaseTimeDimension} timeDimension
     * @return {string}
     */
    dateSeriesSql(timeDimension: import('./BaseTimeDimension').BaseTimeDimension): string;
    /**
     * @param {import('./BaseTimeDimension').BaseTimeDimension} timeDimension
     * @return {string}
     */
    seriesSql(timeDimension: import('./BaseTimeDimension').BaseTimeDimension): string;
    /**
     * @param {import('./BaseDimension').BaseDimension|import('./BaseTimeDimension').BaseTimeDimension} timeDimension
     * @return {string}
     */
    timeStampParam(timeDimension: import('./BaseDimension').BaseDimension | import('./BaseTimeDimension').BaseTimeDimension): string;
    timeRangeFilter(dimensionSql: any, fromTimeStampParam: any, toTimeStampParam: any): string;
    timeNotInRangeFilter(dimensionSql: any, fromTimeStampParam: any, toTimeStampParam: any): string;
    beforeDateFilter(dimensionSql: any, timeStampParam: any): string;
    beforeOrOnDateFilter(dimensionSql: any, timeStampParam: any): string;
    afterDateFilter(dimensionSql: any, timeStampParam: any): string;
    afterOrOnDateFilter(dimensionSql: any, timeStampParam: any): string;
    timeStampCast(value: any): string;
    dateTimeCast(value: any): string;
    commonQuery(): string;
    collectRootMeasureToHieararchy(context: any): {
        [index: string]: any;
    };
    query(): any;
    rewriteInlineCubeSql(cube: any, isLeftJoinCondition: any): any[];
    joinQuery(join: any, subQueryDimensions: any): string;
    joinSql(toJoin: any): string;
    subQueryJoin(dimension: any): {
        sql: string;
        alias: string;
        on: any;
    };
    get filtersWithoutSubQueries(): any;
    filtersWithoutSubQueriesValue: any;
    subQueryDescription(dimension: any): {
        prefix: string;
        subQuery: any;
        cubeName: any;
    };
    subQueryName(cubeName: any, name: any): string;
    regularMeasuresSubQuery(measures: any, filters: any): string;
    /**
     * Returns SQL query for the "aggregating on top of sub-queries" uses cases.
     * @param {string} keyCubeName
     * @param {Array<BaseMeasure>} measures
     * @param {Array<BaseFilter>} filters
     * @returns {string}
     */
    aggregateSubQuery(keyCubeName: string, measures: Array<BaseMeasure>, filters: Array<BaseFilter>): string;
    checkShouldBuildJoinForMeasureSelect(measures: any, keyCubeName: any): any;
    aggregateSubQueryMeasureJoin(keyCubeName: any, measures: any, measuresJoin: any, primaryKeyDimensions: any, measureSubQueryDimensions: any): any;
    groupedUngroupedSelect(select: any, ungrouped: any, granularityOverride: any): any;
    ungroupedMeasureSelect(select: any): any;
    keysQuery(primaryKeyDimensions: any, filters: any): string;
    keysSelect(primaryKeyDimensions: any): string;
    keyDimensions(primaryKeyDimensions: any): (BaseDimension | BaseTimeDimension)[];
    cubeSql(cube: any): any;
    traverseSymbol(s: any): any;
    collectCubeNames(excludeTimeDimensions: any): any;
    collectJoinHints(excludeTimeDimensions?: boolean): any;
    collectFromMembers(excludeTimeDimensions: any, fn: any, methodName: any): any;
    allMembersConcat(excludeTimeDimensions: any): any;
    collectFrom(membersToCollectFrom: any, fn: any, methodName: any, cache: any): any[];
    collectSubQueryDimensionsFor(fn: any): never[];
    rewriteInlineWhere(fn: any, inlineWhereConditions: any): any;
    /**
     * Returns `GROUP BY` clause for the "aggregating on top of sub-queries" uses
     * cases. By the default returns the result of the `groupByClause` method.
     * @returns {string}
     */
    aggregateSubQueryGroupByClause(): string;
    /**
     * Returns `GROUP BY` clause for the basic uses cases.
     * @returns {string}
     */
    groupByClause(): string;
    getFieldIndex(id: any): any;
    orderBy(): string;
    /**
     * Returns a complete list of the aliased dimensions, including time
     * dimensions.
     * @returns {Array<string>}
     */
    dimensionAliasNames(): Array<string>;
    /**
     * Returns an array of column names correlated to the specified cube dimensions.
     * @param {string} cubeAlias
     * @returns {Array<string>}
     */
    dimensionColumns(cubeAlias: string): Array<string>;
    groupByDimensionLimit(): string;
    /**
     * @protected
     * @param {Array<string>} dimensionNames
     * @returns {string}
     */
    protected rollupGroupByClause(dimensionNames: Array<string>): string;
    /**
     * @protected
     * @param limit
     * @param offset
     * @returns {string}
     */
    protected limitOffsetClause(limit: any, offset: any): string;
    topLimit(): string;
    baseSelect(): string;
    selectAllDimensionsAndMeasures(measures: any): string;
    /**
     * @returns {Array<BaseDimension|BaseMeasure>}
     */
    forSelect(): Array<BaseDimension | BaseMeasure>;
    /**
     * Returns a complete list of the dimensions, including time dimensions.
     * @returns {(BaseDimension|BaseTimeDimension)[]}
     */
    dimensionsForSelect(): (BaseDimension | BaseTimeDimension)[];
    dimensionSql(dimension: any): any;
    segmentSql(segment: any): any;
    measureSql(measure: any): any;
    autoPrefixWithCubeName(cubeName: any, sql: any, isMemberExpr?: boolean): any;
    wrapSegmentForDimensionSelect(sql: any): any;
    pushCubeNameForCollectionIfNecessary(cubeName: any): void;
    pushJoinHints(joinHints: any): void;
    pushMemberNameForCollectionIfNecessary(cubeName: any, name: any): void;
    safeEvaluateSymbolContext(): any;
    evaluateSymbolSql(cubeName: any, name: any, symbol: any, memberExpressionType: any): any;
    autoPrefixAndEvaluateSql(cubeName: any, sql: any, isMemberExpr?: boolean): any;
    concatStringsSql(strings: any): any;
    primaryKeyNames(cubeName: any): any;
    primaryKeyName(cubeName: any, primaryKey: any): string;
    evaluateSql(cubeName: any, sql: any, options: any): any;
    withCubeAliasPrefix(cubeAliasPrefix: any, fn: any): any;
    /**
     * Evaluate escaped SQL-alias for cube or cube's property
     * (measure, dimension).
     * @param {string} cubeName
     * @returns string
     */
    cubeAlias(cubeName: string): string;
    collectCubeNamesFor(fn: any): never[];
    collectJoinHintsFor(fn: any): never[];
    collectMemberNamesFor(fn: any): never[];
    collectAllMemberNames(): any[];
    collectMultipliedMeasures(context: any): (fn: any) => any[];
    collectLeafMeasures(fn: any): unknown[];
    evaluateSymbolSqlWithContext(fn: any, context: any): any;
    evaluateSymbolContext: any;
    renderSqlMeasure(name: any, evaluateSql: any, symbol: any, cubeName: any, parentMeasure: any, orderBySql: any): any;
    aggregateOnGroupedColumn(symbol: any, evaluateSql: any, topLevelMerge: any, measurePath: any): string | void;
    topAggregateWrap(symbol: any, evaluateSql: any): any;
    hllInit(_sql: any): void;
    hllMerge(_sql: any): void;
    hllCardinality(_sql: any): void;
    hllMergeOnly(sql: any): void;
    hllCardinalityMerge(sql: any): void;
    castToString(sql: any): string;
    countDistinctApprox(sql: any): void;
    primaryKeyCount(cubeName: any, distinct: any): any;
    renderDimensionCase(symbol: any, cubeName: any): string;
    renderDimensionCaseLabel(label: any, cubeName: any): any;
    caseWhenStatement(when: any, elseLabel: any): string;
    applyMeasureFilters(evaluateSql: any, symbol: any, cubeName: any): any;
    evaluateMeasureFilters(symbol: any, cubeName: any): any;
    evaluateFiltersArray(filtersArray: any, cubeName: any): any;
    primaryKeySql(primaryKeyName: any, cubeName: any): any;
    multipliedJoinRowResult(cubeName: any): any;
    inIntegrationTimeZone(date: any): moment.Moment;
    inDbTimeZone(date: any): string;
    /**
     * @return {string}
     */
    timestampFormat(): string;
    /**
     * @return {number}
     */
    timestampPrecision(): number;
    /**
     * @param {string} field
     * @return {string}
     */
    convertTz(field: string): string;
    timeGroupedColumn(granularity: any, dimension: any): void;
    /**
     * Evaluate alias for specific cube's property.
     * @param {string} name Property name.
     * @param {boolean?} isPreAggregationName Pre-agg flag.
     * @returns {string}
     */
    aliasName(name: string, isPreAggregationName?: boolean | null): string;
    newSubQuery(options: any): any;
    newSubQueryForCube(cube: any, options: any): any;
    subQueryOptions(options: any): any;
    cacheKeyQueries(transformFn: any): any;
    refreshKeysByCubes(cubes: any, transformFn: any): any;
    aggSelectForDimension(cube: any, dimension: any, aggFunction: any): string | null;
    cubeCardinalityQueries(): {
        [index: string]: any;
    };
    renewalThreshold(refreshKeyAllSetManually: any): number;
    nowTimestampSql(): string;
    unixTimestampSql(): string;
    preAggregationTableName(cube: any, preAggregationName: any, skipSchema: any): string;
    preAggregationSchema(): any;
    preAggregationLoadSql(cube: any, preAggregation: any, tableName: any): any[];
    preAggregationPreviewSql(tableName: any): [string, unknown[]];
    indexSql(cube: any, preAggregation: any, index: any, indexName: any, tableName: any): any;
    evaluateIndexColumns(cube: any, index: any): any;
    createIndexSql(indexName: any, tableName: any, escapedColumns: any): string;
    preAggregationSql(cube: any, preAggregation: any): any;
    preAggregationOutputColumnTypes(cube: any, preAggregation: any): any;
    preAggregationUniqueKeyColumns(cube: any, preAggregation: any): any;
    preAggregationReadOnly(_cube: any, _preAggregation: any): boolean;
    preAggregationAllowUngroupingWithPrimaryKey(_cube: any, _preAggregation: any): boolean;
    /**
     * @public
     * @returns {any}
     */
    public sqlTemplates(): any;
    preAggregationQueryForSqlEvaluation(cube: any, preAggregation: any): any;
    parseCronSyntax(every: any): {
        start: cronParser.CronDate;
        end: cronParser.CronDate;
        dayOffset: number;
    };
    calcIntervalForCronString(refreshKey: any): {
        utcOffset: number;
        interval: number;
        dayOffset: number;
    };
    everyRefreshKeySql(refreshKey: any, external?: boolean): any;
    granularityFor(momentDate: any): "day" | "month" | "year" | "week" | "hour" | "minute" | "second";
    /**
     * @protected
     * @param {string} interval
     * @return {[number, string]}
     */
    protected parseInterval(interval: string): [number, string];
    negateInterval(interval: any): string;
    parseSecondDuration(interval: any): number;
    floorSql(numeric: any): string;
    incrementalRefreshKey(query: any, originalRefreshKey: any, options?: {}): any;
    defaultRefreshKeyRenewalThreshold(): number;
    defaultEveryRefreshKey(): {
        every: string;
    };
    /**
     * Some databases can return dynamically column name, for example Cube Store
     *
     * SELECT FLOOR((UNIX_TIMESTAMP()) / 60);
     * +-------------------------------------------+
     * | floor(Int64(1625395697) Divide Int64(60)) |
     * +-------------------------------------------+
     * | 27089928                                  |
     * +-------------------------------------------+
     * 1 row in set (0.00 sec)
     *
     * @protected
     *
     * @param {string} sql
     * @return {string}
     */
    protected refreshKeySelect(sql: string): string;
    preAggregationInvalidateKeyQueries(cube: any, preAggregation: any, preAggregationName: any): any;
    refreshKeyRenewalThresholdForInterval(refreshKey: any, everyWithoutSql?: boolean): number;
    preAggregationStartEndQueries(cube: any, preAggregation: any): any;
    parametrizedContextSymbols(): any;
    parametrizedContextSymbolsValue: any;
    contextSymbolsProxy(symbols: any): any;
    filtersProxy(): {};
    filterGroupFunction(): (...filterParamArgs: any[]) => string;
    flattenAllMembers(excludeSegments?: boolean): any[];
    allBackAliasMembersExceptSegments(): any;
    allBackAliasMembers(): any;
    backAliasMembers(members: any): any;
}
/**
 * Set of the schema compilers.
 */
export type Compilers = {
    compiler: import('../compiler/DataSchemaCompiler').DataSchemaCompiler;
    metaTransformer: import('../compiler/CubeToMetaTransformer').CubeToMetaTransformer;
    cubeEvaluator: import('../compiler/CubeEvaluator').CubeEvaluator;
    contextEvaluator: import('../compiler/ContextEvaluator').ContextEvaluator;
    joinGraph: import('../compiler/JoinGraph').JoinGraph;
    compilerCache: import('../compiler/CompilerCache').CompilerCache;
    headCommitId: any;
};
import { ParamAllocator } from './ParamAllocator';
import { PreAggregations } from './PreAggregations';
import { BaseFilter } from './BaseFilter';
import { BaseGroupFilter } from './BaseGroupFilter';
import { BaseMeasure } from './BaseMeasure';
import { BaseDimension } from './BaseDimension';
import { BaseSegment } from './BaseSegment';
import { BaseTimeDimension } from './BaseTimeDimension';
import R from 'ramda';
import moment from 'moment-timezone';
import cronParser from 'cron-parser';
//# sourceMappingURL=BaseQuery.d.ts.map