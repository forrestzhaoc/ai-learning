export class PreAggregations {
    static transformQueryToCanUseForm(query: any): {
        sortedDimensions: any[];
        sortedTimeDimensions: any;
        timeDimensions: any;
        measures: any[];
        leafMeasureAdditive: boolean;
        leafMeasures: any[];
        measureToLeafMeasures: {};
        hasNoTimeDimensionsWithoutGranularity: boolean;
        allFiltersWithinSelectedDimensions: boolean;
        isAdditive: boolean;
        granularityHierarchies: any;
        hasMultipliedMeasures: boolean;
        hasCumulativeMeasures: boolean;
        windowGranularity: any;
        filterDimensionsSingleValueEqual: any;
        ownedDimensions: any[];
        ownedTimeDimensionsWithRollupGranularity: any;
        ownedTimeDimensionsAsIs: any;
        allBackAliasMembers: any;
        ungrouped: any;
        sortedUsedCubePrimaryKeys: any;
        sortedAllCubeNames: any;
        hasPostAggregate: boolean;
    };
    static ownedMembers(query: any, members: any): any[];
    static sortTimeDimensionsWithRollupGranularity(timeDimensions: any): any;
    static timeDimensionsAsIs(timeDimensions: any): any;
    static collectFilterDimensionsWithSingleValueEqual(filters: any, map: any): any;
    static transformedQueryToReferences(query: any): {
        measures: any;
        dimensions: any;
        timeDimensions: any;
    };
    /**
     * Returns function to determine whether pre-aggregation can be used or not
     * for specified query, or its value for `refs` if specified.
     * @param {Object} transformedQuery transformed query
     * @param {Object?} refs pre-aggs reference
     * @returns {function(preagg: Object): boolean}
     */
    static canUsePreAggregationForTransformedQueryFn(transformedQuery: any, refs: any | null): (arg0: preagg) => any;
    static squashDimensions(query: any, flattenDimensionMembers: any): any[];
    static flattenMembers(members: any): any[];
    static flattenDimensionMembers(query: any): any[];
    static checkPartitionGranularityDefined(cube: any, preAggregationName: any, preAggregation: any): any;
    static memberNameMismatchValidation(preAggA: any, preAggB: any, memberType: any): void;
    static memberShortNames(memberArray: any, isTimeDimension: any): any;
    static hasCumulativeMeasures(query: any): boolean;
    /**
     * @param {import('../adapter/BaseQuery').BaseQuery} query
     * @param historyQueries
     * @param cubeLatticeCache
     */
    constructor(query: import('../adapter/BaseQuery').BaseQuery, historyQueries: any, cubeLatticeCache: any);
    query: import("../adapter/BaseQuery").BaseQuery;
    historyQueries: any;
    cubeLatticeCache: any;
    cubeLattices: {};
    /**
     * @return {unknown[]}
     */
    preAggregationsDescription(): unknown[];
    preAggregationsDescriptionLocal(): any;
    preAggregationCubes(): any;
    preAggregationDescriptionsFor(foundPreAggregation: any): any;
    canPartitionsBeUsed(foundPreAggregation: any): any;
    addPartitionRangeTo(foundPreAggregation: any, dimension: any, range: any, boundaryDateRange: any): any;
    partitionDimension(foundPreAggregation: any): {
        dimension: any;
        partitionDimension: import("./BaseTimeDimension").BaseTimeDimension;
    };
    preAggregationDescriptionsForRecursive(cube: any, foundPreAggregation: any): any;
    get hasCumulativeMeasures(): boolean;
    hasCumulativeMeasuresValue: boolean | undefined;
    aggregationsColumns(cube: any, preAggregation: any): any;
    preAggregationDescriptionFor(cube: any, foundPreAggregation: any): {
        preAggregationId: string;
        timezone: any;
        timestampFormat: any;
        timestampPrecision: any;
        tableName: string;
        invalidateKeyQueries: any;
        partitionInvalidateKeyQueries: any;
        type: any;
        external: any;
        previewSql: any;
        preAggregationsSchema: any;
        loadSql: any;
        sql: any;
        outputColumnTypes: any;
        uniqueKeyColumns: any;
        aggregationsColumns: any;
        dataSource: any;
        granularity: any;
        partitionGranularity: any;
        updateWindowSeconds: any;
        preAggregationStartEndQueries: any;
        matchedTimeDimensionDateRange: any;
        indexesSql: {
            indexName: string;
            sql: any;
        }[];
        createTableIndexes: {
            indexName: string;
            type: any;
            columns: any;
        }[];
        readOnly: any;
        streamOffset: any;
        unionWithSourceData: any;
        rollupLambdaId: any;
        lastRollupLambda: any;
    };
    preAggregationTableName(cube: any, preAggregationName: any, preAggregation: any, skipSchema: any): string;
    findPreAggregationToUseForCube(cube: any): {
        preAggregationName: string;
        preAggregation: unknown;
        cube: any;
        references: any;
    } | null;
    canUsePreAggregationFn(query: any, refs: any): (arg0: preagg) => any;
    canUsePreAggregationAndCheckIfRefValid(query: any): (refs: any) => (arg0: preagg) => any;
    checkAutoRollupPreAggregationValid(refs: any): boolean;
    getCubeLattice(cube: any, preAggregationName: any, preAggregation: any): void;
    /**
     * Returns pre-agg which determined as applicable for the query (the first one
     * from the list of potentially applicable pre-aggs). The order of the
     * potentially applicable pre-aggs is the same as the order in which these
     * pre-aggs appear in the schema file.
     * @returns {Object}
     */
    findPreAggregationForQuery(): any;
    preAggregationForQuery: any;
    findAutoRollupPreAggregationsForCube(cube: any, preAggregations: any): any[];
    /**
     * Returns an array of potencially applicable for the query preaggs in the
     * same order they appear in the schema file.
     * @returns {Array<Object>}
     */
    rollupMatchResults(): Array<any>;
    findRollupPreAggregationsForCube(cube: any, canUsePreAggregation: any, preAggregations: any): {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
        preAggregationId: string;
    }[];
    buildRollupJoin(preAggObj: any, preAggObjsToJoin: any): any;
    preAggObjForJoin(preAggObjsToJoin: any, joinMembers: any, join: any): any;
    resolveJoinMembers(join: any): any;
    cubesFromPreAggregation(preAggObj: any): any[];
    evaluatedPreAggregationObj(cube: any, preAggregationName: any, preAggregation: any, canUsePreAggregation: any): {
        preAggregationName: any;
        preAggregation: any;
        cube: any;
        canUsePreAggregation: any;
        references: any;
        preAggregationId: string;
    };
    rollupMatchResultDescriptions(): {
        name: any;
        tableName: string;
        references: any;
        canUsePreAggregation: any;
    }[];
    canUseTransformedQuery(): {
        sortedDimensions: any[];
        sortedTimeDimensions: any;
        timeDimensions: any;
        measures: any[];
        leafMeasureAdditive: boolean;
        leafMeasures: any[];
        measureToLeafMeasures: {};
        hasNoTimeDimensionsWithoutGranularity: boolean;
        allFiltersWithinSelectedDimensions: boolean;
        isAdditive: boolean;
        granularityHierarchies: any;
        hasMultipliedMeasures: boolean;
        hasCumulativeMeasures: boolean;
        windowGranularity: any;
        filterDimensionsSingleValueEqual: any;
        ownedDimensions: any[];
        ownedTimeDimensionsWithRollupGranularity: any;
        ownedTimeDimensionsAsIs: any;
        allBackAliasMembers: any;
        ungrouped: any;
        sortedUsedCubePrimaryKeys: any;
        sortedAllCubeNames: any;
        hasPostAggregate: boolean;
    };
    castGranularity(granularity: any): any;
    collectOriginalSqlPreAggregations(fn: any): {
        preAggregations: any[];
        result: any;
    };
    refreshRangeQuery(cube: any): any;
    originalSqlPreAggregationQuery(cube: any, aggregation: any): any;
    rollupPreAggregationQuery(cube: any, aggregation: any): any;
    autoRollupPreAggregationQuery(cube: any, aggregation: any): any;
    mergePartitionTimeDimensions(aggregation: any, partitionTimeDimensions: any): any;
    autoRollupNameSuffix(cube: any, aggregation: any): string;
    evaluateAllReferences(cube: any, aggregation: any, preAggregationName: any): any;
    originalSqlPreAggregationTable(preAggregationDescription: any): string;
    rollupLambdaUnion(preAggregationForQuery: any, rollupGranularity: any): any;
    rollupPreAggregation(preAggregationForQuery: any, measures: any, isFullSimpleQuery: any, filters: any): any;
    measuresRenderedReference(preAggregationForQuery: any): {
        [index: number]: unknown;
    };
    measureAliasesRenderedReference(preAggregationForQuery: any): {
        [index: number]: unknown;
    };
    dimensionsRenderedReference(preAggregationForQuery: any): {
        [index: number]: unknown;
    };
    timeDimensionsRenderedReference(rollupGranularity: any, preAggregationForQuery: any): {
        [index: number]: unknown;
    };
    rollupMembers(preAggregationForQuery: any, type: any): any;
    rollupMeasures(preAggregationForQuery: any): any;
    rollupDimensions(preAggregationForQuery: any): any;
    rollupTimeDimensions(preAggregationForQuery: any): any;
    preAggregationId(preAggregation: any): string;
}
//# sourceMappingURL=PreAggregations.d.ts.map