"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrestodbQuery = void 0;
const BaseQuery_1 = require("./BaseQuery");
const BaseFilter_1 = require("./BaseFilter");
const GRANULARITY_TO_INTERVAL = {
    day: 'day',
    week: 'week',
    hour: 'hour',
    minute: 'minute',
    second: 'second',
    month: 'month',
    quarter: 'quarter',
    year: 'year'
};
class PrestodbFilter extends BaseFilter_1.BaseFilter {
    likeIgnoreCase(column, not, param, type) {
        const p = (!type || type === 'contains' || type === 'ends') ? '%' : '';
        const s = (!type || type === 'contains' || type === 'starts') ? '%' : '';
        return `LOWER(${column})${not ? ' NOT' : ''} LIKE CONCAT('${p}', LOWER(${this.allocateParam(param)}) , '${s}') ESCAPE '\\'`;
    }
    castParameter() {
        if (this.definition().type === 'boolean') {
            return 'CAST(? AS BOOLEAN)';
        }
        else if (this.measure || this.definition().type === 'number') {
            // TODO here can be measure type of string actually
            return 'CAST(? AS DOUBLE)';
        }
        return '?';
    }
}
class PrestodbQuery extends BaseQuery_1.BaseQuery {
    newFilter(filter) {
        return new PrestodbFilter(this, filter);
    }
    timeStampParam() {
        return 'from_iso8601_timestamp(?)';
    }
    timeStampCast(value) {
        return `from_iso8601_timestamp(${value})`;
    }
    dateTimeCast(value) {
        return `from_iso8601_timestamp(${value})`;
    }
    convertTz(field) {
        const atTimezone = `${field} AT TIME ZONE '${this.timezone}'`;
        return this.timezone ?
            `CAST(date_add('minute', timezone_minute(${atTimezone}), date_add('hour', timezone_hour(${atTimezone}), ${field})) AS TIMESTAMP)` :
            field;
    }
    timeGroupedColumn(granularity, dimension) {
        return `date_trunc('${GRANULARITY_TO_INTERVAL[granularity]}', ${dimension})`;
    }
    subtractInterval(date, interval) {
        const [intervalValue, intervalUnit] = interval.split(' ');
        return `${date} - interval '${intervalValue}' ${intervalUnit}`;
    }
    addInterval(date, interval) {
        const [intervalValue, intervalUnit] = interval.split(' ');
        return `${date} + interval '${intervalValue}' ${intervalUnit}`;
    }
    seriesSql(timeDimension) {
        const values = timeDimension.timeSeries().map(([from, to]) => `select '${from}' f, '${to}' t`).join(' UNION ALL ');
        return `SELECT from_iso8601_timestamp(dates.f) date_from, from_iso8601_timestamp(dates.t) date_to FROM (${values}) AS dates`;
    }
    unixTimestampSql() {
        return `to_unixtime(${this.nowTimestampSql()})`;
    }
    defaultRefreshKeyRenewalThreshold() {
        return 120;
    }
    defaultEveryRefreshKey() {
        return {
            every: '2 minutes'
        };
    }
    hllInit(sql) {
        return `cast(approx_set(${sql}) as varbinary)`;
    }
    hllMerge(sql) {
        return `cardinality(merge(cast(${sql} as HyperLogLog)))`;
    }
    countDistinctApprox(sql) {
        return `approx_distinct(${sql})`;
    }
    limitOffsetClause(limit, offset) {
        const limitClause = limit != null ? ` LIMIT ${limit}` : '';
        const offsetClause = offset != null ? ` OFFSET ${offset}` : '';
        return `${offsetClause}${limitClause}`;
    }
    sqlTemplates() {
        const templates = super.sqlTemplates();
        templates.functions.DATETRUNC = 'DATE_TRUNC({{ args_concat }})';
        templates.functions.DATEPART = 'DATE_PART({{ args_concat }})';
        templates.statements.select = 'SELECT {{ select_concat | map(attribute=\'aliased\') | join(\', \') }} \n' +
            'FROM (\n  {{ from }}\n) AS {{ from_alias }} \n' +
            '{% if group_by %} GROUP BY {{ group_by }}{% endif %}' +
            '{% if order_by %} ORDER BY {{ order_by | map(attribute=\'expr\') | join(\', \') }}{% endif %}' +
            '{% if offset %}\nOFFSET {{ offset }}{% endif %}' +
            '{% if limit %}\nLIMIT {{ limit }}{% endif %}';
        templates.expressions.extract = 'EXTRACT({{ date_part }} FROM {{ expr }})';
        templates.expressions.interval_single_date_part = 'INTERVAL \'{{ num }}\' {{ date_part }}';
        templates.expressions.timestamp_literal = 'from_iso8601_timestamp(\'{{ value }}\')';
        templates.types.string = 'VARCHAR';
        templates.types.float = 'REAL';
        // Presto intervals have a YearMonth or DayTime type variants, but no universal type
        delete templates.types.interval;
        templates.types.binary = 'VARBINARY';
        return templates;
    }
}
exports.PrestodbQuery = PrestodbQuery;
//# sourceMappingURL=PrestodbQuery.js.map