import { BaseDimension } from './BaseDimension';
import type { BaseQuery } from './BaseQuery';
export declare class BaseFilter extends BaseDimension {
    readonly measure: any;
    readonly operator: any;
    readonly values: any;
    readonly camelizeOperator: any;
    constructor(query: BaseQuery, filter: any);
    filterToWhere(): any;
    convertTzForRawTimeDimensionIfNeeded(sql: any): any;
    measureFilterToWhere(): any;
    conditionSql(columnSql: any): any;
    measureDefinition(): import("../compiler/CubeEvaluator").MeasureDefinition;
    path(): any;
    cube(): any;
    definition(): import("../compiler/CubeEvaluator").MeasureDefinition | import("../compiler/CubeEvaluator").SegmentDefinition;
    escapeWildcardChars(param: any): any;
    isWildcardOperator(): boolean;
    filterParams(): any[];
    isDateOperator(): boolean;
    valuesArray(): any[];
    valuesContainNull(): boolean;
    castParameter(): string;
    firstParameter(): string;
    allocateCastParam(param: any): string;
    allocateTimestampParam(param: any): string;
    allocateTimestampParams(): string[];
    allParamsRepeat(basePart: any): string[];
    isArrayValues(): boolean;
    containsWhere(column: any): string;
    notContainsWhere(column: any): string;
    /**
     * Returns SQL statement for the `startsWith` filter.
     * @param {string} column Column name.
     * @returns string
     */
    startsWithWhere(column: any): string;
    /**
     * Returns SQL statement for the `notStartsWith` filter.
     * @param {string} column Column name.
     * @returns string
     */
    notStartsWithWhere(column: any): string;
    /**
     * Returns SQL statement for the `endsWith` filter.
     * @param {string} column Column name.
     * @returns string
     */
    endsWithWhere(column: any): string;
    /**
     * Returns SQL statement for the `endsWith` filter.
     * @param {string} column Column name.
     * @returns string
     */
    notEndsWithWhere(column: any): string;
    /**
     * Returns SQL filter statement (union with the logical OR) for the
     * provided parameters.
     * @param {string} column Column name.
     * @param {boolean} not Flag to build NOT LIKE statement.
     * @param {string} type Type of the condition (i.e. contains/
     * startsWith/endsWith).
     * @returns string
     */
    likeOr(column: any, not: any, type: any): string;
    /**
     * Returns SQL LIKE statement for specified parameters.
     * @param {string} column Column name.
     * @param {boolean} not Flag to build NOT LIKE statement.
     * @param {*} param Value for statement.
     * @param {string} type Type of the condition (i.e. contains/startsWith/endsWith).
     * @returns string
     */
    likeIgnoreCase(column: any, not: any, param: any, type: any): string;
    orIsNullCheck(column: any, not: any): string;
    shouldAddOrIsNull(not: any): boolean;
    allocateParam(param: any): string;
    equalsWhere(column: any): string;
    inPlaceholders(): string;
    inWhere(column: any): string;
    notEqualsWhere(column: any): string;
    notInWhere(column: any): string;
    setWhere(column: any): string;
    notSetWhere(column: any): string;
    gtWhere(column: any): string;
    gteWhere(column: any): string;
    ltWhere(column: any): string;
    lteWhere(column: any): string;
    expressionEqualsWhere(column: any): string;
    inDateRangeWhere(column: any): string;
    notInDateRangeWhere(column: any): string;
    onTheDateWhere(column: any): string;
    beforeDateWhere(column: any): string;
    beforeOrOnDateWhere(column: any): string;
    afterDateWhere(column: any): string;
    afterOrOnDateWhere(column: any): string;
    formatFromDate(date: string): string;
    inDbTimeZoneDateFrom(date: any): any;
    formatToDate(date: string): string;
    inDbTimeZoneDateTo(date: any): any;
    formattedDateRange(): string[];
    unescapedAliasName(): string;
}
//# sourceMappingURL=BaseFilter.d.ts.map