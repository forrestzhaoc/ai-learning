"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseMeasure = void 0;
const UserError_1 = require("../compiler/UserError");
class BaseMeasure {
    constructor(query, measure) {
        this.query = query;
        this.measure = measure;
        this.isMemberExpression = false;
        if (measure.expression) {
            this.expression = measure.expression;
            this.expressionCubeName = measure.cubeName;
            // In case of SQL push down expressionName doesn't contain cube name. It's just a column name.
            this.expressionName = measure.expressionName || `${measure.cubeName}.${measure.name}`;
            this.isMemberExpression = !!measure.definition;
        }
    }
    getMembers() {
        return [this];
    }
    selectColumns() {
        return [`${this.measureSql()} ${this.aliasName()}`];
    }
    hasNoRemapping() {
        return this.measureSql() === this.aliasName();
    }
    cumulativeSelectColumns() {
        return [`${this.cumulativeMeasureSql()} ${this.aliasName()}`];
    }
    cumulativeMeasureSql() {
        return this.query.evaluateSymbolSqlWithContext(() => this.measureSql(), {
            ungroupedAliasesForCumulative: { [this.measure]: this.aliasName() }
        });
    }
    measureSql() {
        if (this.expression) {
            return this.convertTzForRawTimeDimensionIfNeeded(() => this.query.evaluateSymbolSql(this.expressionCubeName, this.expressionName, this.definition(), 'measure'));
        }
        return this.query.measureSql(this);
    }
    // We need this for measures however we don't for filters for performance reasons
    convertTzForRawTimeDimensionIfNeeded(sql) {
        if (this.query.options.convertTzForRawTimeDimension) {
            return this.query.evaluateSymbolSqlWithContext(sql, {
                convertTzForRawTimeDimension: true
            });
        }
        else {
            return sql();
        }
    }
    cube() {
        if (this.expression) {
            return this.query.cubeEvaluator.cubeFromPath(this.expressionCubeName);
        }
        return this.query.cubeEvaluator.cubeFromPath(this.measure);
    }
    measureDefinition() {
        return this.query.cubeEvaluator.measureByPath(this.measure);
    }
    definition() {
        if (this.expression) {
            return {
                sql: this.expression,
                // TODO use actual measure type even though it isn't used right now
                type: 'number'
            };
        }
        return this.measureDefinition();
    }
    aliasName() {
        return this.query.escapeColumnName(this.unescapedAliasName());
    }
    unescapedAliasName() {
        if (this.expression) {
            return this.query.aliasName(this.expressionName);
        }
        return this.query.aliasName(this.measure);
    }
    isCumulative() {
        if (this.expression) { // TODO
            return false;
        }
        return BaseMeasure.isCumulative(this.measureDefinition());
    }
    isPostAggregate() {
        if (this.expression) { // TODO
            return false;
        }
        return this.definition().postAggregate;
    }
    isAdditive() {
        if (this.expression) { // TODO
            return false;
        }
        const definition = this.measureDefinition();
        if (definition.postAggregate) {
            return false;
        }
        return definition.type === 'sum' || definition.type === 'count' || definition.type === 'countDistinctApprox' ||
            definition.type === 'min' || definition.type === 'max';
    }
    static isCumulative(definition) {
        return definition.type === 'runningTotal' || !!definition.rollingWindow;
    }
    rollingWindowDefinition() {
        if (this.measureDefinition().type === 'runningTotal') {
            throw new UserError_1.UserError('runningTotal rollups aren\'t supported. Please consider replacing runningTotal measure with rollingWindow.');
        }
        const { type } = this.measureDefinition().rollingWindow;
        if (type && type !== 'fixed') {
            throw new UserError_1.UserError(`Only fixed rolling windows are supported by Cube Store but got '${type}' rolling window`);
        }
        return this.measureDefinition().rollingWindow;
    }
    dateJoinCondition() {
        const definition = this.measureDefinition();
        if (definition.type === 'runningTotal') {
            return this.query.runningTotalDateJoinCondition();
        }
        const { rollingWindow } = definition;
        if (rollingWindow.type === 'to_date') {
            return this.query.rollingWindowToDateJoinCondition(rollingWindow.granularity);
        }
        // TODO deprecated
        if (rollingWindow.type === 'year_to_date' || rollingWindow.type === 'quarter_to_date' || rollingWindow.type === 'month_to_date') {
            return this.query.rollingWindowToDateJoinCondition(rollingWindow.type.replace('_to_date', ''));
        }
        if (rollingWindow) {
            return this.query.rollingWindowDateJoinCondition(rollingWindow.trailing, rollingWindow.leading, rollingWindow.offset);
        }
        return null;
    }
    windowGranularity() {
        const { rollingWindow } = this.measureDefinition();
        if (rollingWindow) {
            return this.minGranularity(this.granularityFromInterval(rollingWindow.leading), this.granularityFromInterval(rollingWindow.trailing));
        }
        return undefined;
    }
    minGranularity(granularityA, granularityB) {
        return this.query.minGranularity(granularityA, granularityB);
    }
    granularityFromInterval(interval) {
        if (!interval) {
            return undefined;
        }
        if (interval.match(/day/)) {
            return 'day';
        }
        else if (interval.match(/month/)) {
            return 'month';
        }
        else if (interval.match(/year/)) {
            return 'year';
        }
        else if (interval.match(/week/)) {
            return 'week';
        }
        else if (interval.match(/hour/)) {
            return 'hour';
        }
        return undefined;
    }
    shouldUngroupForCumulative() {
        return this.measureDefinition().rollingWindow && !this.isAdditive();
    }
    sqlDefinition() {
        return this.measureDefinition().sql;
    }
    path() {
        if (this.expression) {
            return null;
        }
        return this.query.cubeEvaluator.parsePath('measures', this.measure);
    }
    expressionPath() {
        if (this.expression) {
            return `expr:${this.expression.expressionName}`;
        }
        return this.query.cubeEvaluator.pathFromArray(this.path());
    }
}
exports.BaseMeasure = BaseMeasure;
//# sourceMappingURL=BaseMeasure.js.map