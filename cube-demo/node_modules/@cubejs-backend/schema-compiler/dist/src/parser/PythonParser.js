"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonParser = void 0;
/* eslint-disable no-underscore-dangle,camelcase */
const antlr4ts_1 = require("antlr4ts");
const t = __importStar(require("@babel/types"));
const Python3Lexer_1 = require("./Python3Lexer");
const Python3Parser_1 = require("./Python3Parser");
const UserError_1 = require("../compiler/UserError");
const nodeVisitor = (visitor) => ({
    // TODO null -- note used?
    visit: () => null,
    visitTerminal: null,
    visitErrorNode: null,
    visitChildren(node) {
        if (!node) {
            return null;
        }
        const result = [];
        for (let i = 0; i < node.childCount; i++) {
            const child = node.getChild(i);
            if (child && child.childCount) {
                result.push(child.accept(this));
            }
        }
        return visitor.visitNode(node, result);
    }
});
class PythonParser {
    constructor(codeString) {
        this.codeString = codeString;
        this.errors = [];
        this.ast = this.parse();
    }
    parse() {
        const { codeString } = this;
        const chars = antlr4ts_1.CharStreams.fromString(codeString);
        chars.getText = (interval) => {
            const start = interval.a;
            let stop = interval.b;
            if (stop >= chars.size) {
                stop = chars.size - 1;
            }
            if (start >= chars.size) {
                return '';
            }
            else {
                return codeString.slice(start, stop + 1);
            }
        };
        const { errors } = this;
        class ExprErrorListener {
            syntaxError(recognizer, offendingSymbol, line, column, msg, err) {
                errors.push({
                    msg, column, err, line, recognizer, offendingSymbol
                });
            }
        }
        const lexer = new Python3Lexer_1.Python3Lexer(chars);
        lexer.removeErrorListeners();
        lexer.addErrorListener(new ExprErrorListener());
        const commonTokenStream = new antlr4ts_1.CommonTokenStream(lexer);
        const parser = new Python3Parser_1.Python3Parser(commonTokenStream);
        parser.buildParseTree = true;
        parser.removeErrorListeners();
        parser.addErrorListener(new ExprErrorListener());
        return parser.file_input();
    }
    transpileToJs() {
        return this.ast.accept(nodeVisitor({
            visitNode: (node, children) => {
                const singleNodeReturn = () => {
                    if (children.length === 1) {
                        return children[0];
                    }
                    else {
                        throw new UserError_1.UserError(`Unsupported Python multiple children node: ${node.constructor.name}: ${node.text}`);
                    }
                };
                if (node instanceof Python3Parser_1.File_inputContext) {
                    return t.program(children);
                }
                else if (node instanceof Python3Parser_1.Expr_stmtContext) {
                    if (children.length === 1) {
                        return t.expressionStatement(children[0]);
                    }
                    else {
                        throw new UserError_1.UserError(`Unsupported Python multiple children node: ${node.constructor.name}: ${node.text}`);
                    }
                }
                else if (node instanceof Python3Parser_1.Double_string_template_atomContext ||
                    node instanceof Python3Parser_1.Single_string_template_atomContext) {
                    if ((node.test() || node.star_expr()) && children.length === 1) {
                        return children[0];
                    }
                    return t.templateElement({ raw: node.text, cooked: node.text });
                }
                else if (node instanceof Python3Parser_1.String_templateContext) {
                    if (children[children.length - 1].type === 'TemplateElement') {
                        children[children.length - 1].tail = true;
                    }
                    else {
                        children.push(t.templateElement({ raw: '', cooked: '' }));
                    }
                    if (children[0].type !== 'TemplateElement') {
                        children.unshift(t.templateElement({ raw: '', cooked: '' }));
                    }
                    return t.templateLiteral(children.filter(c => c.type === 'TemplateElement'), children.filter(c => c.type !== 'TemplateElement'));
                }
                else if (node instanceof Python3Parser_1.Atom_exprContext) {
                    if (children.length === 1) {
                        return children[0];
                    }
                    else if (children.length > 1) {
                        let expr = children[0];
                        for (let i = 1; i < children.length; i++) {
                            if (children[i].call) {
                                expr = t.callExpression(expr, children[i].call);
                            }
                            else if (children[i].identifier) {
                                expr = t.memberExpression(expr, children[i].identifier);
                            }
                            else {
                                throw new Error(`Unexpected trailer child: ${children[i]}`);
                            }
                        }
                        return expr;
                    }
                    else {
                        throw new UserError_1.UserError(`Empty Python atom_expr node: ${node.constructor.name}: ${node.text}`);
                    }
                }
                else if (node instanceof Python3Parser_1.AtomContext) {
                    const name = node.NAME();
                    const string = node.STRING();
                    if (name) {
                        return t.identifier(name.text);
                    }
                    else if (string?.length) {
                        return t.stringLiteral(string.map(s => this.stripQuotes(s.text)).join(''));
                    }
                    else {
                        return singleNodeReturn();
                    }
                }
                else if (node instanceof Python3Parser_1.TrailerContext) {
                    const name = node.NAME();
                    const argsList = node.arglist();
                    if (argsList) {
                        // trailer with arglist have a single child: arguments _list_
                        const args = children[0];
                        return { call: args };
                    }
                    else if (name) {
                        return { identifier: t.identifier(name.text) };
                    }
                    else {
                        throw new UserError_1.UserError(`Unsupported Python Trailer children node: ${node.constructor.name}: ${node.text}`);
                    }
                }
                else if (node instanceof Python3Parser_1.VfpdefContext) {
                    const name = node.NAME();
                    if (name) {
                        return t.identifier(name.text);
                    }
                    else {
                        throw new UserError_1.UserError(`Unsupported Python vfpdef children node: ${node.constructor.name}: ${node.text}`);
                    }
                }
                else if (node instanceof Python3Parser_1.VarargslistContext) {
                    return { args: children };
                }
                else if (node instanceof Python3Parser_1.LambdefContext) {
                    return t.arrowFunctionExpression(children[0].args, children[1]);
                }
                else if (node instanceof Python3Parser_1.ArglistContext) {
                    return children;
                }
                else {
                    return singleNodeReturn();
                }
            }
        }));
    }
    stripQuotes(text) {
        if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === '\'' && text[text.length - 1] === '\'') {
            return text.slice(1, text.length - 1);
        }
        else {
            return text;
        }
    }
    canParse() {
        return !this.errors.length;
    }
    throwErrorsIfAny() {
        if (this.errors.length) {
            throw new UserError_1.UserError(`Python Parsing Error:\n${this.errors.map(({ msg, column, line }) => `${line}:${column} ${msg}`).join('\n')}`);
        }
    }
}
exports.PythonParser = PythonParser;
//# sourceMappingURL=PythonParser.js.map