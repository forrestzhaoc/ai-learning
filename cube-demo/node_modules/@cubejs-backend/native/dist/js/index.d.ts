export interface BaseMeta {
    protocol: string;
    apiType: string;
    appName?: string;
}
export interface LoadRequestMeta extends BaseMeta {
    changeUser?: string;
}
export interface Request<Meta> {
    id: string;
    meta: Meta;
}
export interface CheckAuthResponse {
    password: string | null;
    superuser: boolean;
    securityContext: any;
    skipPasswordCheck?: boolean;
}
export interface CheckAuthPayload {
    request: Request<undefined>;
    user: string | null;
    password: string | null;
}
export interface SessionContext {
    user: string | null;
    superuser: boolean;
    securityContext: any;
}
export interface LoadPayload {
    request: Request<LoadRequestMeta>;
    session: SessionContext;
    query: any;
}
export interface SqlPayload {
    request: Request<LoadRequestMeta>;
    session: SessionContext;
    query: any;
    memberToAlias: Record<string, string>;
    expressionParams: string[];
}
export interface SqlApiLoadPayload {
    request: Request<LoadRequestMeta>;
    session: SessionContext;
    query: any;
    queryKey: any;
    sqlQuery: any;
    streaming: boolean;
}
export interface LogLoadEventPayload {
    request: Request<LoadRequestMeta>;
    session: SessionContext;
    event: string;
    properties: any;
}
export interface MetaPayload {
    request: Request<undefined>;
    session: SessionContext;
    onlyCompilerId?: boolean;
}
export interface CanSwitchUserPayload {
    session: SessionContext;
    user: string;
}
export type SQLInterfaceOptions = {
    pgPort?: number;
    checkAuth: (payload: CheckAuthPayload) => CheckAuthResponse | Promise<CheckAuthResponse>;
    load: (payload: LoadPayload) => unknown | Promise<unknown>;
    sql: (payload: SqlPayload) => unknown | Promise<unknown>;
    meta: (payload: MetaPayload) => unknown | Promise<unknown>;
    stream: (payload: LoadPayload) => unknown | Promise<unknown>;
    sqlApiLoad: (payload: SqlApiLoadPayload) => unknown | Promise<unknown>;
    logLoadEvent: (payload: LogLoadEventPayload) => unknown | Promise<unknown>;
    sqlGenerators: (paramsJson: string) => unknown | Promise<unknown>;
    canSwitchUserForSession: (payload: CanSwitchUserPayload) => unknown | Promise<unknown>;
    gatewayPort?: number;
};
export declare function loadNative(): any;
export declare function isSupported(): boolean;
type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace';
export declare const setupLogger: (logger: (extra: any) => unknown, logLevel: LogLevel) => void;
export declare const isFallbackBuild: () => boolean;
export type SqlInterfaceInstance = {
    __typename: 'sqlinterfaceinstance';
};
export declare const registerInterface: (options: SQLInterfaceOptions) => Promise<SqlInterfaceInstance>;
export type ShutdownMode = 'fast' | 'semifast' | 'smart';
export declare const shutdownInterface: (instance: SqlInterfaceInstance, shutdownMode: ShutdownMode) => Promise<void>;
export declare const execSql: (instance: SqlInterfaceInstance, sqlQuery: string, stream: any, securityContext?: any) => Promise<void>;
export declare const buildSqlAndParams: (cubeEvaluator: any) => String;
export interface PyConfiguration {
    repositoryFactory?: (ctx: unknown) => Promise<unknown>;
    logger?: (msg: string, params: Record<string, any>) => void;
    checkAuth?: (req: unknown, authorization: string) => Promise<{
        'security_context'?: unknown;
    }>;
    queryRewrite?: (query: unknown, ctx: unknown) => Promise<unknown>;
    contextToApiScopes?: () => Promise<string[]>;
}
export declare const pythonLoadConfig: (content: string, options: {
    fileName: string;
}) => Promise<PyConfiguration>;
export type PythonCtx = {
    __type: 'PythonCtx';
} & {
    filters: Record<string, Function>;
    functions: Record<string, Function>;
    variables: Record<string, any>;
};
export type JinjaEngineOptions = {
    debugInfo?: boolean;
    filters: Record<string, Function>;
    workers: number;
};
export interface JinjaEngine {
    loadTemplate(templateName: string, templateContent: string): void;
    renderTemplate(templateName: string, context: unknown, pythonContext: Record<string, any> | null): Promise<string>;
}
export declare class NativeInstance {
    protected native: any | null;
    protected getNative(): any;
    newJinjaEngine(options: JinjaEngineOptions): JinjaEngine;
    loadPythonContext(fileName: string, content: unknown): Promise<PythonCtx>;
}
export {};
//# sourceMappingURL=index.d.ts.map