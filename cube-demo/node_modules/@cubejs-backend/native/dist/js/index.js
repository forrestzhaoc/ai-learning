"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeInstance = exports.pythonLoadConfig = exports.buildSqlAndParams = exports.execSql = exports.shutdownInterface = exports.registerInterface = exports.isFallbackBuild = exports.setupLogger = exports.isSupported = exports.loadNative = void 0;
/* eslint-disable import/no-dynamic-require,global-require */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const stream_1 = require("stream");
function loadNative() {
    // Development version
    if (fs_1.default.existsSync(path_1.default.join(__dirname, '/../../index.node'))) {
        return require(path_1.default.join(__dirname, '/../../index.node'));
    }
    if (fs_1.default.existsSync(path_1.default.join(__dirname, '/../../native/index.node'))) {
        return require(path_1.default.join(__dirname, '/../../native/index.node'));
    }
    throw new Error(`Unable to load @cubejs-backend/native, probably your system (${process.arch}-${process.platform}) with Node.js ${process.version} is not supported.`);
}
exports.loadNative = loadNative;
function isSupported() {
    return fs_1.default.existsSync(path_1.default.join(__dirname, '/../../index.node')) || fs_1.default.existsSync(path_1.default.join(__dirname, '/../../native/index.node'));
}
exports.isSupported = isSupported;
function wrapNativeFunctionWithChannelCallback(fn) {
    return async (extra, channel) => {
        try {
            const result = await fn(JSON.parse(extra));
            if (process.env.CUBEJS_NATIVE_INTERNAL_DEBUG) {
                console.debug('[js] channel.resolve', {
                    result,
                });
            }
            if (!result) {
                channel.resolve('');
            }
            else {
                channel.resolve(JSON.stringify(result));
            }
        }
        catch (e) {
            if (process.env.CUBEJS_NATIVE_INTERNAL_DEBUG) {
                console.debug('[js] channel.reject', {
                    e,
                });
            }
            try {
                channel.reject(e.message || 'Unknown JS exception');
            }
            catch (rejectErr) {
                if (process.env.CUBEJS_NATIVE_INTERNAL_DEBUG) {
                    console.debug('[js] channel.reject exception', {
                        e: rejectErr,
                    });
                }
            }
            // throw e;
        }
    };
}
function wrapRawNativeFunctionWithChannelCallback(fn) {
    return async (extra, channel) => {
        try {
            const result = await fn(extra);
            if (process.env.CUBEJS_NATIVE_INTERNAL_DEBUG) {
                console.debug('[js] channel.resolve', {
                    result,
                });
            }
            channel.resolve(result);
        }
        catch (e) {
            if (process.env.CUBEJS_NATIVE_INTERNAL_DEBUG) {
                console.debug('[js] channel.reject', {
                    e,
                });
            }
            try {
                channel.reject(e.message || e.toString());
            }
            catch (error) {
                if (process.env.CUBEJS_NATIVE_INTERNAL_DEBUG) {
                    console.debug('[js] channel.reject exception', {
                        e: error,
                    });
                }
            }
            // throw e;
        }
    };
}
const errorString = (err) => err.error ||
    err.message ||
    err.stack?.toString() ||
    (typeof err === 'string' ? err.toString() : JSON.stringify(err));
// TODO: Refactor - define classes
function wrapNativeFunctionWithStream(fn) {
    const chunkLength = parseInt(process.env.CUBEJS_DB_QUERY_STREAM_HIGH_WATER_MARK || '8192', 10);
    return async (extra, writerOrChannel) => {
        let response;
        try {
            response = await fn(JSON.parse(extra));
            if (response && response.stream) {
                writerOrChannel.start();
                let chunkBuffer = [];
                const writable = new stream_1.Writable({
                    objectMode: true,
                    highWaterMark: chunkLength,
                    write(row, encoding, callback) {
                        chunkBuffer.push(row);
                        if (chunkBuffer.length < chunkLength) {
                            callback(null);
                        }
                        else {
                            const toSend = chunkBuffer;
                            chunkBuffer = [];
                            writerOrChannel.chunk(toSend, callback);
                        }
                    },
                    final(callback) {
                        const end = (err) => {
                            if (err) {
                                callback(err);
                            }
                            else {
                                writerOrChannel.end(callback);
                            }
                        };
                        if (chunkBuffer.length > 0) {
                            const toSend = chunkBuffer;
                            chunkBuffer = [];
                            writerOrChannel.chunk(toSend, end);
                        }
                        else {
                            end(null);
                        }
                    },
                    destroy(error, callback) {
                        if (error) {
                            writerOrChannel.reject(errorString(error));
                        }
                        callback(null);
                    },
                });
                response.stream.pipe(writable);
                response.stream.on('error', (err) => {
                    writable.destroy(err);
                });
            }
            else if (response.error) {
                writerOrChannel.reject(errorString(response));
            }
            else {
                // TODO remove JSON.stringify()
                writerOrChannel.resolve(JSON.stringify(response));
            }
        }
        catch (e) {
            if (!!response && !!response.stream) {
                response.stream.destroy(e);
            }
            writerOrChannel.reject(errorString(e));
        }
    };
}
const setupLogger = (logger, logLevel) => {
    const native = loadNative();
    native.setupLogger({ logger: wrapNativeFunctionWithChannelCallback(logger), logLevel });
};
exports.setupLogger = setupLogger;
const isFallbackBuild = () => {
    const native = loadNative();
    return native.isFallbackBuild();
};
exports.isFallbackBuild = isFallbackBuild;
const registerInterface = async (options) => {
    if (typeof options !== 'object' && options == null) {
        throw new Error('Argument options must be an object');
    }
    if (typeof options.checkAuth !== 'function') {
        throw new Error('options.checkAuth must be a function');
    }
    if (typeof options.load !== 'function') {
        throw new Error('options.load must be a function');
    }
    if (typeof options.meta !== 'function') {
        throw new Error('options.meta must be a function');
    }
    if (typeof options.stream !== 'function') {
        throw new Error('options.stream must be a function');
    }
    if (typeof options.sqlApiLoad !== 'function') {
        throw new Error('options.sqlApiLoad must be a function');
    }
    if (typeof options.sqlGenerators !== 'function') {
        throw new Error('options.sqlGenerators must be a function');
    }
    if (typeof options.sql !== 'function') {
        throw new Error('options.sql must be a function');
    }
    const native = loadNative();
    return native.registerInterface({
        ...options,
        checkAuth: wrapNativeFunctionWithChannelCallback(options.checkAuth),
        load: wrapNativeFunctionWithChannelCallback(options.load),
        sql: wrapNativeFunctionWithChannelCallback(options.sql),
        meta: wrapNativeFunctionWithChannelCallback(options.meta),
        stream: wrapNativeFunctionWithStream(options.stream),
        sqlApiLoad: wrapNativeFunctionWithStream(options.sqlApiLoad),
        sqlGenerators: wrapRawNativeFunctionWithChannelCallback(options.sqlGenerators),
        logLoadEvent: wrapRawNativeFunctionWithChannelCallback(options.logLoadEvent),
        canSwitchUserForSession: wrapRawNativeFunctionWithChannelCallback(options.canSwitchUserForSession),
    });
};
exports.registerInterface = registerInterface;
const shutdownInterface = async (instance, shutdownMode) => {
    const native = loadNative();
    await native.shutdownInterface(instance, shutdownMode);
};
exports.shutdownInterface = shutdownInterface;
const execSql = async (instance, sqlQuery, stream, securityContext) => {
    const native = loadNative();
    await native.execSql(instance, sqlQuery, stream, securityContext ? JSON.stringify(securityContext) : null);
};
exports.execSql = execSql;
const buildSqlAndParams = (cubeEvaluator) => {
    const native = loadNative();
    return native.buildSqlAndParams(cubeEvaluator);
};
exports.buildSqlAndParams = buildSqlAndParams;
function simplifyExpressRequest(req) {
    // Req is a large object, let's simplify it
    // Important: Dont pass circular references
    return {
        url: req.url,
        method: req.method,
        headers: req.headers,
        ip: req.ip,
    };
}
const pythonLoadConfig = async (content, options) => {
    if ((0, exports.isFallbackBuild)()) {
        throw new Error('Python is not supported in fallback build');
    }
    const native = loadNative();
    const config = await native.pythonLoadConfig(content, options);
    if (config.checkAuth) {
        const nativeCheckAuth = config.checkAuth;
        config.checkAuth = async (req, authorization) => {
            const nativeResult = await nativeCheckAuth(simplifyExpressRequest(req), authorization);
            const securityContext = nativeResult?.security_context;
            return {
                ...(securityContext ? { security_context: securityContext } : {})
            };
        };
    }
    if (config.extendContext) {
        const nativeExtendContext = config.extendContext;
        config.extendContext = async (req) => nativeExtendContext(simplifyExpressRequest(req));
    }
    if (config.repositoryFactory) {
        const nativeRepositoryFactory = config.repositoryFactory;
        config.repositoryFactory = (ctx) => ({
            dataSchemaFiles: async () => nativeRepositoryFactory(ctx),
        });
    }
    if (config.logger) {
        const nativeLogger = config.logger;
        config.logger = (msg, params) => {
            nativeLogger(msg, params).catch((e) => {
                console.error(e);
            });
        };
    }
    return config;
};
exports.pythonLoadConfig = pythonLoadConfig;
class NativeInstance {
    constructor() {
        this.native = null;
    }
    getNative() {
        if (this.native) {
            return this.native;
        }
        this.native = loadNative();
        return this.native;
    }
    newJinjaEngine(options) {
        return this.getNative().newJinjaEngine(options);
    }
    loadPythonContext(fileName, content) {
        if ((0, exports.isFallbackBuild)()) {
            throw new Error('Python (loadPythonContext) is not supported because you are using the fallback build of native extension. Read more: ' +
                'https://github.com/cube-js/cube/blob/master/packages/cubejs-backend-native/README.md#supported-architectures-and-platforms');
        }
        return this.getNative().pythonLoadModel(fileName, content);
    }
}
exports.NativeInstance = NativeInstance;
//# sourceMappingURL=index.js.map