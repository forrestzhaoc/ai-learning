"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reformatInIsoLocal = exports.addSecondsToLocalTimestamp = exports.extractDate = exports.utcToLocalTimeZone = exports.inDbTimeZone = exports.BUILD_RANGE_END_LOCAL = exports.BUILD_RANGE_START_LOCAL = exports.TO_PARTITION_RANGE = exports.FROM_PARTITION_RANGE = exports.timeSeries = exports.TIME_SERIES = void 0;
const moment_range_1 = require("moment-range");
const Moment = require('moment-timezone');
const moment = (0, moment_range_1.extendMoment)(Moment);
exports.TIME_SERIES = {
    day: (range, digits) => Array.from(range.snapTo('day').by('day'))
        .map(d => [d.format(`YYYY-MM-DDT00:00:00.${'0'.repeat(digits)}`), d.format(`YYYY-MM-DDT23:59:59.${'9'.repeat(digits)}`)]),
    month: (range, digits) => Array.from(range.snapTo('month').by('month'))
        .map(d => [d.format(`YYYY-MM-01T00:00:00.${'0'.repeat(digits)}`), d.endOf('month').format(`YYYY-MM-DDT23:59:59.${'9'.repeat(digits)}`)]),
    year: (range, digits) => Array.from(range.snapTo('year').by('year'))
        .map(d => [d.format(`YYYY-01-01T00:00:00.${'0'.repeat(digits)}`), d.endOf('year').format(`YYYY-MM-DDT23:59:59.${'9'.repeat(digits)}`)]),
    hour: (range, digits) => Array.from(range.snapTo('hour').by('hour'))
        .map(d => [d.format(`YYYY-MM-DDTHH:00:00.${'0'.repeat(digits)}`), d.format(`YYYY-MM-DDTHH:59:59.${'9'.repeat(digits)}`)]),
    minute: (range, digits) => Array.from(range.snapTo('minute').by('minute'))
        .map(d => [d.format(`YYYY-MM-DDTHH:mm:00.${'0'.repeat(digits)}`), d.format(`YYYY-MM-DDTHH:mm:59.${'9'.repeat(digits)}`)]),
    second: (range, digits) => Array.from(range.snapTo('second').by('second'))
        .map(d => [d.format(`YYYY-MM-DDTHH:mm:ss.${'0'.repeat(digits)}`), d.format(`YYYY-MM-DDTHH:mm:ss.${'9'.repeat(digits)}`)]),
    week: (range, digits) => Array.from(range.snapTo('isoWeek').by('week'))
        .map(d => [d.startOf('isoWeek').format(`YYYY-MM-DDT00:00:00.${'0'.repeat(digits)}`), d.endOf('isoWeek').format(`YYYY-MM-DDT23:59:59.${'9'.repeat(digits)}`)]),
    quarter: (range, digits) => Array.from(range.snapTo('quarter').by('quarter'))
        .map(d => [d.format(`YYYY-MM-DDT00:00:00.${'0'.repeat(digits)}`), d.endOf('quarter').format(`YYYY-MM-DDT23:59:59.${'9'.repeat(digits)}`)]),
};
const timeSeries = (granularity, dateRange, options = { timestampPrecision: 3 }) => {
    if (!exports.TIME_SERIES[granularity]) {
        // TODO error
        throw new Error(`Unsupported time granularity: ${granularity}`);
    }
    if (!options.timestampPrecision) {
        throw new Error(`options.timestampPrecision is required, actual: ${options.timestampPrecision}`);
    }
    // moment.range works with strings
    const range = moment.range(dateRange[0], dateRange[1]);
    return exports.TIME_SERIES[granularity](range, options.timestampPrecision);
};
exports.timeSeries = timeSeries;
exports.FROM_PARTITION_RANGE = '__FROM_PARTITION_RANGE';
exports.TO_PARTITION_RANGE = '__TO_PARTITION_RANGE';
exports.BUILD_RANGE_START_LOCAL = '__BUILD_RANGE_START_LOCAL';
exports.BUILD_RANGE_END_LOCAL = '__BUILD_RANGE_END_LOCAL';
const inDbTimeZone = (timezone, timestampFormat, timestamp) => {
    if (timestamp.length === 23 || timestamp.length === 26) {
        const zone = moment.tz.zone(timezone);
        if (!zone) {
            throw new Error(`Unknown timezone: ${timezone}`);
        }
        const parsedTime = Date.parse(`${timestamp}Z`);
        const offset = zone.utcOffset(parsedTime);
        const inDbTimeZoneDate = new Date(parsedTime + offset * 60 * 1000);
        if (timestampFormat === 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' || timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSSZ') {
            return inDbTimeZoneDate.toJSON();
        }
        else if (timestampFormat === 'YYYY-MM-DD[T]HH:mm:ss.SSSSSS[Z]' || timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSSSSSZ') {
            const value = inDbTimeZoneDate.toJSON();
            if (value.endsWith('999Z')) {
                // emulate microseconds
                return value.replace('Z', '999Z');
            }
            // emulate microseconds
            return value.replace('Z', '000Z');
        }
        else if (timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSS') {
            return inDbTimeZoneDate.toJSON().replace('Z', '');
        }
        else if (timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSSSSS') {
            // emulate microseconds
            return inDbTimeZoneDate.toJSON().replace('Z', '000');
        }
    }
    // moment doesn't support microseconds,
    // it will fill it with zeros
    return moment.tz(timestamp, timezone).utc().format(timestampFormat);
};
exports.inDbTimeZone = inDbTimeZone;
const utcToLocalTimeZone = (timezone, timestampFormat, timestamp) => {
    if (timestamp.length === 23) {
        const zone = moment.tz.zone(timezone);
        if (!zone) {
            throw new Error(`Unknown timezone: ${timezone}`);
        }
        const parsedTime = Date.parse(`${timestamp}Z`);
        // TODO parsedTime might be incorrect offset for conversion
        const offset = zone.utcOffset(parsedTime);
        const inDbTimeZoneDate = new Date(parsedTime - offset * 60 * 1000);
        if (timestampFormat === 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' || timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSSZ') {
            return inDbTimeZoneDate.toJSON();
        }
        else if (timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSS') {
            return inDbTimeZoneDate.toJSON().replace('Z', '');
        }
    }
    return moment.tz(timestamp, 'UTC').tz(timezone).format(timestampFormat);
};
exports.utcToLocalTimeZone = utcToLocalTimeZone;
const extractDate = (data) => {
    if (!data) {
        return null;
    }
    data = JSON.parse(JSON.stringify(data));
    const value = data[0] && data[0][Object.keys(data[0])[0]];
    if (!value) {
        return value;
    }
    return moment.tz(value, 'UTC').utc().format(moment.HTML5_FMT.DATETIME_LOCAL_MS);
};
exports.extractDate = extractDate;
const addSecondsToLocalTimestamp = (timestamp, timezone, seconds) => {
    if (timestamp.length === 23) {
        const zone = moment.tz.zone(timezone);
        if (!zone) {
            throw new Error(`Unknown timezone: ${timezone}`);
        }
        const parsedTime = Date.parse(`${timestamp}Z`);
        const offset = zone.utcOffset(parsedTime);
        return new Date(parsedTime + offset * 60 * 1000 + seconds * 1000);
    }
    return moment.tz(timestamp, timezone)
        .add(seconds, 'second')
        .toDate();
};
exports.addSecondsToLocalTimestamp = addSecondsToLocalTimestamp;
const reformatInIsoLocal = (timestamp) => {
    if (!timestamp) {
        return timestamp;
    }
    if (timestamp.length === 23) {
        return timestamp;
    }
    if (timestamp.length === 24) {
        return timestamp.replace('Z', '');
    }
    return moment.tz(timestamp, 'UTC').utc().format(moment.HTML5_FMT.DATETIME_LOCAL_MS);
};
exports.reformatInIsoLocal = reformatInIsoLocal;
//# sourceMappingURL=time.js.map