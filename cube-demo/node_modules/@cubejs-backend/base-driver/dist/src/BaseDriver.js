"use strict";
/**
 * @copyright Cube Dev, Inc.
 * @license Apache-2.0
 * @fileoverview The `BaseDriver` and related types declaration.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDriver = void 0;
const shared_1 = require("@cubejs-backend/shared");
const ramda_1 = require("ramda");
const fs_1 = __importDefault(require("fs"));
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
const client_s3_1 = require("@aws-sdk/client-s3");
const utils_1 = require("./utils");
const driver_interface_1 = require("./driver.interface");
const sortByKeys = (unordered) => {
    const ordered = {};
    Object.keys(unordered).sort().forEach((key) => {
        ordered[key] = unordered[key];
    });
    return ordered;
};
const DbTypeToGenericType = {
    'timestamp without time zone': 'timestamp',
    'character varying': 'text',
    varchar: 'text',
    integer: 'int',
    nvarchar: 'text',
    text: 'text',
    string: 'text',
    boolean: 'boolean',
    bigint: 'bigint',
    time: 'string',
    datetime: 'timestamp',
    date: 'date',
    enum: 'text',
    'double precision': 'double',
    // PostgreSQL aliases, but maybe another databases support it
    int8: 'bigint',
    int4: 'int',
    int2: 'int',
    bool: 'boolean',
    float4: 'float',
    float8: 'double',
};
const DB_BIG_INT_MAX = BigInt('9223372036854775807');
const DB_BIG_INT_MIN = BigInt('-9223372036854775808');
const DB_INT_MAX = 2147483647;
const DB_INT_MIN = -2147483648;
// Order of keys is important here: from more specific to less specific
const DbTypeValueMatcher = {
    timestamp: (v) => v instanceof Date || v.toString().match(/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d/),
    date: (v) => v instanceof Date || v.toString().match(/^\d\d\d\d-\d\d-\d\d$/),
    int: (v) => {
        if (Number.isInteger(v)) {
            return (v <= DB_INT_MAX && v >= DB_INT_MIN);
        }
        if (v.toString().match(/^[-]?\d+$/)) {
            const value = BigInt(v.toString());
            return value <= DB_INT_MAX && value >= DB_INT_MIN;
        }
        return false;
    },
    bigint: (v) => {
        if (Number.isInteger(v)) {
            return (v <= DB_BIG_INT_MAX && v >= DB_BIG_INT_MIN);
        }
        if (v.toString().match(/^[-]?\d+$/)) {
            const value = BigInt(v.toString());
            return value <= DB_BIG_INT_MAX && value >= DB_BIG_INT_MIN;
        }
        return false;
    },
    decimal: (v) => {
        if (v instanceof Number) {
            return true;
        }
        return v.toString().match(/^[-]?\d+(\.\d+)?$/);
    },
    boolean: (v) => v === false || v === true || v.toString().toLowerCase() === 'true' || v.toString().toLowerCase() === 'false',
    string: (v) => v.length < 256,
    text: () => true
};
/**
 * Base driver class.
 */
class BaseDriver {
    /**
     * Class constructor.
     */
    constructor(_options = {}) {
        this.testConnectionTimeoutValue = 10000;
        this.testConnectionTimeoutValue = _options.testConnectionTimeout || 10000;
    }
    informationSchemaQuery() {
        return `
      SELECT columns.column_name as ${this.quoteIdentifier('column_name')},
             columns.table_name as ${this.quoteIdentifier('table_name')},
             columns.table_schema as ${this.quoteIdentifier('table_schema')},
             columns.data_type as ${this.quoteIdentifier('data_type')}
      FROM information_schema.columns
      WHERE columns.table_schema NOT IN ('pg_catalog', 'information_schema', 'mysql', 'performance_schema', 'sys', 'INFORMATION_SCHEMA')
   `;
    }
    getSchemasQuery() {
        return `
      SELECT table_schema as ${this.quoteIdentifier('schema_name')}
      FROM information_schema.tables
      WHERE table_schema NOT IN ('pg_catalog', 'information_schema', 'mysql', 'performance_schema', 'sys', 'INFORMATION_SCHEMA')
      GROUP BY table_schema
    `;
    }
    getTablesForSpecificSchemasQuery(schemasPlaceholders) {
        const query = `
      SELECT table_schema as ${this.quoteIdentifier('schema_name')},
            table_name as ${this.quoteIdentifier('table_name')}
      FROM information_schema.tables as columns
      WHERE table_schema IN (${schemasPlaceholders})
    `;
        return query;
    }
    getColumnsForSpecificTablesQuery(conditionString) {
        const query = `
      SELECT columns.column_name as ${this.quoteIdentifier('column_name')},
             columns.table_name as ${this.quoteIdentifier('table_name')},
             columns.table_schema as ${this.quoteIdentifier('schema_name')},
             columns.data_type as ${this.quoteIdentifier('data_type')}
      FROM information_schema.columns as columns
      WHERE ${conditionString}
    `;
        return query;
    }
    primaryKeysQuery(_) {
        return null;
    }
    foreignKeysQuery(_) {
        return null;
    }
    async primaryKeys(conditionString, params) {
        const query = this.primaryKeysQuery(conditionString);
        if (!query) {
            return [];
        }
        try {
            return (await this.query(query, params));
        }
        catch (error) {
            if (this.logger) {
                this.logger('Primary Keys Query failed. Primary Keys will be defined by heuristics', {
                    error: (error.stack || error).toString()
                });
            }
            return [];
        }
    }
    async foreignKeys(conditionString, params) {
        const query = this.foreignKeysQuery(conditionString);
        if (!query) {
            return [];
        }
        try {
            return (await this.query(query, params));
        }
        catch (error) {
            if (this.logger) {
                this.logger('Foreign Keys Query failed. Joins will be defined by heuristics', {
                    error: (error.stack || error).toString()
                });
            }
            return [];
        }
    }
    getColumnNameForSchemaName() {
        return 'columns.table_schema';
    }
    getColumnNameForTableName() {
        return 'columns.table_name';
    }
    getSslOptions(dataSource) {
        if ((0, shared_1.getEnv)('dbSsl', { dataSource }) ||
            (0, shared_1.getEnv)('dbSslRejectUnauthorized', { dataSource })) {
            const sslOptions = [{
                    name: 'ca',
                    canBeFile: true,
                    envKey: (0, shared_1.keyByDataSource)('CUBEJS_DB_SSL_CA', dataSource),
                    validate: shared_1.isSslCert,
                }, {
                    name: 'cert',
                    canBeFile: true,
                    envKey: (0, shared_1.keyByDataSource)('CUBEJS_DB_SSL_CERT', dataSource),
                    validate: shared_1.isSslCert,
                }, {
                    name: 'key',
                    canBeFile: true,
                    envKey: (0, shared_1.keyByDataSource)('CUBEJS_DB_SSL_KEY', dataSource),
                    validate: shared_1.isSslKey,
                }, {
                    name: 'ciphers',
                    envKey: (0, shared_1.keyByDataSource)('CUBEJS_DB_SSL_CIPHERS', dataSource),
                }, {
                    name: 'passphrase',
                    envKey: (0, shared_1.keyByDataSource)('CUBEJS_DB_SSL_PASSPHRASE', dataSource),
                }, {
                    name: 'servername',
                    envKey: (0, shared_1.keyByDataSource)('CUBEJS_DB_SSL_SERVERNAME', dataSource),
                }];
            const ssl = sslOptions.reduce((agg, { name, envKey, canBeFile, validate }) => {
                const value = process.env[envKey];
                if (value) {
                    if (validate && validate(value)) {
                        return {
                            ...agg,
                            ...{ [name]: value }
                        };
                    }
                    if (canBeFile && (0, shared_1.isFilePath)(value)) {
                        if (!fs_1.default.existsSync(value)) {
                            throw new Error(`Unable to find ${name} from path: "${value}"`);
                        }
                        const file = fs_1.default.readFileSync(value, 'utf8');
                        if (validate(file)) {
                            return {
                                ...agg,
                                ...{ [name]: file }
                            };
                        }
                        throw new Error(`Content of the file from ${envKey} is not a valid SSL ${name}.`);
                    }
                    throw new Error(`${envKey} is not a valid SSL ${name}. If it's a path, please specify it correctly`);
                }
                return agg;
            }, {});
            ssl.rejectUnauthorized = (0, shared_1.getEnv)('dbSslRejectUnauthorized', { dataSource });
            return ssl;
        }
        return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async streamQuery(sql, values) {
        throw new TypeError('Driver\'s .streamQuery() method is not implemented yet.');
    }
    async downloadQueryResults(query, values, _options) {
        const rows = await this.query(query, values);
        if (rows.length === 0) {
            throw new Error('Unable to detect column types for pre-aggregation on empty values in readOnly mode.');
        }
        const fields = Object.keys(rows[0]);
        const types = fields.map(field => ({
            name: field,
            type: Object.keys(DbTypeValueMatcher).find(type => !rows.filter(row => field in row).find(row => !DbTypeValueMatcher[type](row[field])) &&
                rows.find(row => field in row)) || 'text'
        }));
        return {
            rows,
            types,
        };
    }
    readOnly() {
        return false;
    }
    informationColumnsSchemaReducer(result, i) {
        let schema = (result[i.table_schema] || {});
        const tables = (schema[i.table_name] || []);
        tables.push({
            name: i.column_name,
            type: i.data_type,
            attributes: i.key_type ? ['primaryKey'] : []
        });
        tables.sort();
        schema[i.table_name] = tables;
        schema = sortByKeys(schema);
        result[i.table_schema] = schema;
        return sortByKeys(result);
    }
    tablesSchema() {
        const query = this.informationSchemaQuery();
        return this.query(query).then(data => (0, ramda_1.reduce)(this.informationColumnsSchemaReducer, {}, data));
    }
    // Extended version of tablesSchema containing primary and foreign keys
    async tablesSchemaV2() {
        const tablesSchema = await this.tablesSchema();
        const [primaryKeys, foreignKeys] = await Promise.all([this.primaryKeys(), this.foreignKeys()]);
        for (const pk of primaryKeys) {
            if (Array.isArray(tablesSchema?.[pk.table_schema]?.[pk.table_name])) {
                tablesSchema[pk.table_schema][pk.table_name] = tablesSchema[pk.table_schema][pk.table_name].map((it) => {
                    if (it.name === pk.column_name) {
                        it.attributes = ['primaryKey'];
                    }
                    return it;
                });
            }
        }
        for (const foreignKey of foreignKeys) {
            if (Array.isArray(tablesSchema?.[foreignKey.table_schema]?.[foreignKey.table_name])) {
                tablesSchema[foreignKey.table_schema][foreignKey.table_name] = tablesSchema[foreignKey.table_schema][foreignKey.table_name].map((it) => {
                    if (it.name === foreignKey.column_name) {
                        it.foreign_keys = [...(it.foreign_keys || []), {
                                target_table: foreignKey.target_table,
                                target_column: foreignKey.target_column
                            }];
                    }
                    return it;
                });
            }
        }
        return tablesSchema;
    }
    async createSchemaIfNotExists(schemaName) {
        const schemas = await this.query(`SELECT schema_name FROM information_schema.schemata WHERE schema_name = ${this.param(0)}`, [schemaName]);
        if (schemas.length === 0) {
            await this.query(`CREATE SCHEMA IF NOT EXISTS ${schemaName}`);
        }
    }
    getSchemas() {
        const query = this.getSchemasQuery();
        return this.query(query);
    }
    getTablesForSpecificSchemas(schemas) {
        const schemasPlaceholders = schemas.map((_, idx) => this.param(idx)).join(', ');
        const schemaNames = schemas.map(s => s.schema_name);
        const query = this.getTablesForSpecificSchemasQuery(schemasPlaceholders);
        return this.query(query, schemaNames);
    }
    async getColumnsForSpecificTables(tables) {
        const groupedBySchema = {};
        tables.forEach((t) => {
            if (!groupedBySchema[t.schema_name]) {
                groupedBySchema[t.schema_name] = [];
            }
            groupedBySchema[t.schema_name].push(t.table_name);
        });
        const conditions = [];
        const parameters = [];
        for (const [schema, tableNames] of Object.entries(groupedBySchema)) {
            const schemaPlaceholder = this.param(parameters.length);
            parameters.push(schema);
            const tablePlaceholders = tableNames.map((_, idx) => this.param(parameters.length + idx)).join(', ');
            parameters.push(...tableNames);
            conditions.push(`(${this.getColumnNameForSchemaName()} = ${schemaPlaceholder} AND ${this.getColumnNameForTableName()} IN (${tablePlaceholders}))`);
        }
        const conditionString = conditions.join(' OR ');
        const query = this.getColumnsForSpecificTablesQuery(conditionString);
        const [primaryKeys, foreignKeys] = await Promise.all([
            this.primaryKeys(conditionString, parameters),
            this.foreignKeys(conditionString, parameters)
        ]);
        const columns = await this.query(query, parameters);
        for (const column of columns) {
            if (primaryKeys.some(pk => pk.table_schema === column.schema_name && pk.table_name === column.table_name && pk.column_name === column.column_name)) {
                column.attributes = ['primaryKey'];
            }
            column.foreign_keys = foreignKeys.filter(fk => fk.table_schema === column.schema_name && fk.table_name === column.table_name && fk.column_name === column.column_name).map(fk => ({
                target_table: fk.target_table,
                target_column: fk.target_column
            }));
        }
        return columns;
    }
    getTablesQuery(schemaName) {
        return this.query(`SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.param(0)}`, [schemaName]);
    }
    loadPreAggregationIntoTable(_preAggregationTableName, loadSql, params, options) {
        return this.query(loadSql, params, options);
    }
    dropTable(tableName, options) {
        return this.query(`DROP TABLE ${tableName}`, [], options);
    }
    param(_paramIndex) {
        return '?';
    }
    testConnectionTimeout() {
        return this.testConnectionTimeoutValue;
    }
    async downloadTable(table, _options) {
        return { rows: await this.query(`SELECT * FROM ${table}`) };
    }
    async uploadTable(table, columns, tableData) {
        return this.uploadTableWithIndexes(table, columns, tableData, [], null, [], {});
    }
    async uploadTableWithIndexes(table, columns, tableData, indexesSql, _uniqueKeyColumns, _queryTracingObj, _externalOptions) {
        if (!(0, driver_interface_1.isDownloadTableMemoryData)(tableData)) {
            throw new Error(`${this.constructor} driver supports only rows upload`);
        }
        await this.createTable(table, columns);
        try {
            if ((0, driver_interface_1.isDownloadTableMemoryData)(tableData)) {
                for (let i = 0; i < tableData.rows.length; i++) {
                    await this.query(`INSERT INTO ${table}
          (${columns.map(c => this.quoteIdentifier(c.name)).join(', ')})
          VALUES (${columns.map((c, paramIndex) => this.param(paramIndex)).join(', ')})`, columns.map(c => this.toColumnValue(tableData.rows[i][c.name], c.type)));
                }
                for (let i = 0; i < indexesSql.length; i++) {
                    const [query, params] = indexesSql[i].sql;
                    await this.query(query, params);
                }
            }
        }
        catch (e) {
            await this.dropTable(table);
            throw e;
        }
    }
    toColumnValue(value, _genericType) {
        return value;
    }
    async tableColumnTypes(table) {
        const [schema, name] = table.split('.');
        const columns = await this.query(`SELECT columns.column_name as ${this.quoteIdentifier('column_name')},
             columns.table_name as ${this.quoteIdentifier('table_name')},
             columns.table_schema as ${this.quoteIdentifier('table_schema')},
             columns.data_type  as ${this.quoteIdentifier('data_type')}
      FROM information_schema.columns
      WHERE table_name = ${this.param(0)} AND table_schema = ${this.param(1)}
      ${(0, shared_1.getEnv)('fetchColumnsByOrdinalPosition') ? 'ORDER BY columns.ordinal_position' : ''}`, [name, schema]);
        return columns.map(c => ({ name: c.column_name, type: this.toGenericType(c.data_type) }));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async queryColumnTypes(sql, params) {
        return [];
    }
    createTable(quotedTableName, columns) {
        const createTableSql = this.createTableSql(quotedTableName, columns);
        return this.query(createTableSql, []).catch(e => {
            e.message = `Error during create table: ${createTableSql}: ${e.message}`;
            throw e;
        });
    }
    createTableSql(quotedTableName, columns) {
        const columnNames = columns.map(c => `${this.quoteIdentifier(c.name)} ${this.fromGenericType(c.type)}`);
        return `CREATE TABLE ${quotedTableName} (${columnNames.join(', ')})`;
    }
    toGenericType(columnType) {
        return DbTypeToGenericType[columnType.toLowerCase()] || columnType;
    }
    fromGenericType(columnType) {
        return columnType;
    }
    quoteIdentifier(identifier) {
        return `"${identifier}"`;
    }
    cancelCombinator(fn) {
        return (0, utils_1.cancelCombinator)(fn);
    }
    setLogger(logger) {
        this.logger = logger;
    }
    reportQueryUsage(usage, queryOptions) {
        if (this.logger) {
            this.logger('SQL Query Usage', {
                ...usage,
                ...queryOptions
            });
        }
    }
    databasePoolError(error) {
        if (this.logger) {
            this.logger('Database Pool Error', {
                error: (error.stack || error).toString()
            });
        }
    }
    async release() {
        // override, if it's needed
    }
    capabilities() {
        return {};
    }
    nowTimestamp() {
        return Date.now();
    }
    wrapQueryWithLimit(query) {
        query.query = `SELECT * FROM (${query.query}) AS t LIMIT ${query.limit}`;
    }
    /**
     * Returns an array of signed AWS S3 URLs of the unloaded csv files.
     */
    async extractUnloadedFilesFromS3(clientOptions, bucketName, prefix) {
        const storage = new client_s3_1.S3(clientOptions);
        const list = await storage.listObjectsV2({
            Bucket: bucketName,
            Prefix: prefix,
        });
        if (list) {
            if (!list.Contents) {
                return [];
            }
            else {
                const csvFile = await Promise.all(list.Contents.map(async (file) => {
                    const command = new client_s3_1.GetObjectCommand({
                        Bucket: bucketName,
                        Key: file.Key,
                    });
                    return (0, s3_request_presigner_1.getSignedUrl)(storage, command, { expiresIn: 3600 });
                }));
                return csvFile;
            }
        }
        throw new Error('Unable to retrieve list of files from S3 storage after unloading.');
    }
}
exports.BaseDriver = BaseDriver;
//# sourceMappingURL=BaseDriver.js.map